(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{434:function(t,a,s){t.exports=s.p+"assets/img/1175f990-cd89-11eb-85f6-6fac77c0c9b3.9438b4a6.png"},845:function(t,a,s){"use strict";s.r(a);var e=s(14),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("hr"),t._v(" "),a("h1",{attrs:{id:"jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[t._v("#")]),t._v(" JWT")]),t._v(" "),a("p",[t._v("在目前前后端分离的开发过程中，使用"),a("code",[t._v("token")]),t._v("鉴权机制用于身份验证是最常见的方案，流程如下：")]),t._v(" "),a("ul",[a("li",[t._v("服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证")]),t._v(" "),a("li",[t._v("后续访问会根据这个令牌判断用户时候有权限进行访问")])]),t._v(" "),a("p",[a("code",[t._v("Token")]),t._v("，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以"),a("code",[t._v(".")]),t._v("进行拼接。其中头部和载荷都是以"),a("code",[t._v("JSON")]),t._v("格式存放数据，只是进行了编码")]),t._v(" "),a("p",[a("img",{attrs:{src:s(434),alt:"img"}})]),t._v(" "),a("p",[t._v("Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（"),a("a",{attrs:{href:"https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc7519",target:"_blank",rel:"noopener noreferrer"}},[t._v("(RFC 7519 (opens new window)"),a("OutboundLink")],1),t._v(").该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。")]),t._v(" "),a("p",[t._v("jwt主要有下面这三部分组成")]),t._v(" "),a("h3",{attrs:{id:"基本信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本信息"}},[t._v("#")]),t._v(" 基本信息")]),t._v(" "),a("p",[t._v("JWT实际上要保存到客户端的，服务端不进行存储。客户端每次请求都会携带JWT数据，然后服务端那边只需要验证一下JWT是否合法即可（服务器可以通过JWT获取用户信息）。")]),t._v(" "),a("p",[t._v("JWT是无状态的，所以最重要的安全问题就是攻击者截取了Token数据后就可以伪造用户发送请求。")]),t._v(" "),a("p",[t._v("无状态: 无状态服务不会在本地存储持久化数据.多个实例可以共享相同的持久化数据")]),t._v(" "),a("p",[t._v("JWT其实返回的是一个JSON对象。但是为了防止数据被篡改，所以会加上签名")]),t._v(" "),a("h3",{attrs:{id:"三个字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三个字段"}},[t._v("#")]),t._v(" 三个字段")]),t._v(" "),a("p",[t._v("下面一次介绍一下这三部分")]),t._v(" "),a("p",[a("strong",[t._v("header")])]),t._v(" "),a("p",[t._v("Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"alg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"HS256"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"typ"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"JWT"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("上面代码中，"),a("code",[t._v("alg")]),t._v("属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；"),a("code",[t._v("typ")]),t._v("属性表示这个令牌（token）的类型（type），JWT 令牌统一写为"),a("code",[t._v("JWT")]),t._v("。")]),t._v(" "),a("p",[t._v("最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。")]),t._v(" "),a("p",[a("strong",[t._v("Payload")])]),t._v(" "),a("p",[t._v("Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。")]),t._v(" "),a("ul",[a("li",[t._v("iss (issuer)：签发人")]),t._v(" "),a("li",[t._v("exp (expiration time)：过期时间")]),t._v(" "),a("li",[t._v("sub (subject)：主题")]),t._v(" "),a("li",[t._v("aud (audience)：受众")]),t._v(" "),a("li",[t._v("nbf (Not Before)：生效时间")]),t._v(" "),a("li",[t._v("iat (Issued At)：签发时间")]),t._v(" "),a("li",[t._v("jti (JWT ID)：编号")])]),t._v(" "),a("p",[t._v("除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"sub"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1234567890"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"John Doe"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v('"admin"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。")])]),t._v(" "),a("p",[a("strong",[t._v("签名字段")])]),t._v(" "),a("p",[t._v("Signature 部分是对前两部分的签名，防止数据篡改。")]),t._v(" "),a("p",[t._v("首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HMACSHA256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("base64UrlEncode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("header"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"."')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("base64UrlEncode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("payload"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  secret"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v('算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（'),a("code",[t._v(".")]),t._v("）分隔，就可以返回给用户。")]),t._v(" "),a("h3",{attrs:{id:"常用的加密算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用的加密算法"}},[t._v("#")]),t._v(" 常用的加密算法")]),t._v(" "),a("p",[t._v("JWT中最常用的两种算法为"),a("code",[t._v("HMAC")]),t._v("和"),a("code",[t._v("RSA")]),t._v("。")]),t._v(" "),a("p",[a("code",[t._v("HMAC")]),t._v("是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。")]),t._v(" "),a("p",[a("code",[t._v("RSA")]),t._v("则是一种非对称加密算法，使用私钥加密明文，公钥解密密文。")]),t._v(" "),a("h3",{attrs:{id:"base64url"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base64url"}},[t._v("#")]),t._v(" Base64URL")]),t._v(" "),a("p",[t._v("前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。")]),t._v(" "),a("p",[t._v("JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符"),a("code",[t._v("+")]),t._v("、"),a("code",[t._v("/")]),t._v("和"),a("code",[t._v("=")]),t._v("，在 URL 里面有特殊含义，所以要被替换掉："),a("code",[t._v("=")]),t._v("被省略、"),a("code",[t._v("+")]),t._v("替换成"),a("code",[t._v("-")]),t._v("，"),a("code",[t._v("/")]),t._v("替换成"),a("code",[t._v("_")]),t._v(" 。这就是 Base64URL 算法。")]),t._v(" "),a("h3",{attrs:{id:"jwt的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jwt的特点"}},[t._v("#")]),t._v(" JWT的特点")]),t._v(" "),a("p",[t._v("（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。")]),t._v(" "),a("p",[t._v("（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。")]),t._v(" "),a("p",[t._v("（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。")]),t._v(" "),a("p",[t._v("（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。")]),t._v(" "),a("p",[t._v("（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。")]),t._v(" "),a("p",[t._v("（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。")]),t._v(" "),a("h3",{attrs:{id:"java测试demo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java测试demo"}},[t._v("#")]),t._v(" Java测试demo")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' private static final long TOKENEXPIRATION = 1000*60*60*24; //一天\n    private static final String TOKENSIGNKEY = "testSign"; \n    @Test\n    public  void testCreateToken(){\n\n        //JWT构造器\n        JwtBuilder jwtBuilder = Jwts.builder();\n        //JWT三部分 : 头/载荷/签名哈希\n        String jwtToken = jwtBuilder\n                //头: 算法,类型\n                .setHeaderParam("alg","HS256")\n                .setHeaderParam("typ","JWT")\n                //载荷: 自定义信息 可包含用户身份信息\n                .claim("test01","测试")\n                .claim("test02","222")\n                .claim("role","22")\n                //生效时间\n                //.setIssuedAt()\n                //有效载荷 7个默认字段\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis()+ TOKENEXPIRATION)) //过期时间\n                .setId(UUID.randomUUID().toString())\n                //签名哈希\n                .signWith(SignatureAlgorithm.HS256,TOKENSIGNKEY)\n\n                //组装,连接\n                .compact();\n\n        log.error("jwtToken:{}",jwtToken);\n\n    }\n\n    @Test\n    public void getUserInfoByJwtToken(){\n        String jwtToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0MDEiOiLmtYvor5UiLCJ0ZXN0MDIiOiIyMjIiLCJyb2xlIjoiMjIiLCJpYXQiOjE2ODQzMjAyMDYsImV4cCI6MTY4NDQwNjYwNiwianRpIjoiODQzODFkMzYtMzRiZS00MWNlLWJkZjEtNTc1NjhiYzk1ODNjIn0.t8KwuU66yjco5lXrSGT2vt9-bOdTQWFBAnVhOYV6WrA";\n        JwtParser jwtParser = Jwts.parser();\n        //获取载荷\n        Jws<Claims> claimsJws = jwtParser.setSigningKey(TOKENSIGNKEY).parseClaimsJws(jwtToken);\n        Claims claimsJwtBody = claimsJws.getBody();\n        String companyId = (String)claimsJwtBody.get("test01");\n        String uid = (String)claimsJwtBody.get("test02");\n        String role = (String)claimsJwtBody.get("role");\n\n        log.info("{},{},{}",companyId,uid,role);\n\n    }\n')])])])])}),[],!1,null,null,null);a.default=n.exports}}]);