(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{844:function(v,_,t){"use strict";t.r(_);var a=t(14),p=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"java面试-基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java面试-基础"}},[v._v("#")]),v._v(" Java面试（基础）")]),v._v(" "),_("ol",[_("li",[v._v("==与equals的区别")])]),v._v(" "),_("p",[v._v("= =是判断两个对象的地址是否相同，基本数据类型比较值，引用类型比较地址")]),v._v(" "),_("p",[v._v("equals也是判断对象是否相同，若没有覆盖equals方法则相等于==，否则直接比较内容。")]),v._v(" "),_("p",[v._v("Java的数据类型           int         long      short    float    double    char             byte     boolean")]),v._v(" "),_("p",[v._v("包装类（java.lang）：Integer Long     Short    Float   Double    Character    Byte     Boolean")]),v._v(" "),_("p",[v._v("包装类的作用：")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("作为和基本数据类型对应的类存在，方便涉及到对象的操作")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("包含每种基本数据类型的相关属性，如最大值最小值，以及相关的操作方法")]),v._v(" "),_("p",[v._v("相互转换：")]),v._v(" "),_("p",[v._v("○将int转为Integer：  int n=5;  Integer n1 = new Integer(n);")]),v._v(" "),_("p",[v._v("○将Integer转为int：Integer n = new Integer(50);    int n2 = n.intValue();")]),v._v(" "),_("p",[v._v("自动装箱：Integer n = 5；")]),v._v(" "),_("p",[v._v("自动拆箱：int n1 = n；")]),v._v(" "),_("p",[v._v("注意：Integer n = 5；实际上相当于执行 Integer n = Integer.valueOf(5); 这个方法会返回一个对象，只是在返回之前会判断当前的值是否在[-128,127]，且缓存中是否存在此对象，如果存在则直接返回引用，否则创建一个新的对象。当值超过这个范围时，就会创建一个新的Integer对象。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1283027/1631619389360-719e9463-6e93-4d85-9d86-008a0b521d19.png",alt:"image.png"}})]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("hashCode与equals（HashSet查重）")])]),v._v(" "),_("p",[v._v("HashSet查重来举例说明，在向HashSet中存值的时候，会先计算哈希值并判断是否存在相同的哈希值，如果   不存在则直接加入；如果存在则通过equals方法进一步判断两个对象是否相同，若相同则不加入，因此重写equals时必须重写hashCode方法。")]),v._v(" "),_("p",[v._v("hashCode() 与 equals()的相关规定：")]),v._v(" "),_("p",[v._v("■两个对象相等，hashcode一定相同")]),v._v(" "),_("p",[v._v("■两个对象相等，调用equals方法返回true")]),v._v(" "),_("p",[v._v("■两个对象hashcode相同，但不一定相等（哈希冲突，不同key指向相同值）")]),v._v(" "),_("p",[v._v("综上：重写equals方法就必须重写hashCode方法")]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("String与StringBuffer，StringBuilder的区别")])]),v._v(" "),_("p",[v._v("可变性：String对象是不可变的，底层是使用final修饰的字符数组，而另外两个使用的也是字符数组来保存字符串，但没有使用final修饰，因此大小可以改变。")]),v._v(" "),_("p",[v._v("安全性：String大小不可变线程安全，StringBuffer是线程安全的，因为所有方法使用了synchronized关键字")]),v._v(" "),_("p",[v._v("String不可变的好处：")]),v._v(" "),_("p",[v._v("○保证多线程下的运行安全；")]),v._v(" "),_("p",[v._v("○字符串常用来作为参数，如果可变则可能出现严重的安全问题；")]),v._v(" "),_("p",[v._v("○实现字符串池，节约堆空间")]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("什么是反射机制？反射机制的应用场景")])]),v._v(" "),_("p",[v._v("Java反射机制是在运行状态中，对任意一个类都能知道这个类的所有方法和属性；对于任意一个对象，都能调用它的所有方法和属性；这种动态获取的信息和动态调用方法的\t功能称之为Java的反射机制。")]),v._v(" "),_("p",[v._v("使用场景：一般很少用到反射，但在我们平常使用的Spring等框架中经常使用反射机制，比如在进行JDBC数据库连接时，需要通过反射Class.forName()来加载数据库驱动，\t另外就是Spring在加载Bean时也会用到反射。")]),v._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[v._v("JDK，JRE，JVM的区别")])]),v._v(" "),_("p",[v._v("JDK是Java开发工具箱，是功能齐全的Java SDK，包含javac，能够创建和编译程序。")]),v._v(" "),_("p",[v._v("JRE是Java的运行环境，它是运行java程序所需内容的集合，包含JVM，java类库等")]),v._v(" "),_("p",[v._v("JVM是Java虚拟机，负责运行Java字节码（.class文件），JVM有针对不同系统的特定\t实现，因此保证了Java可以在多平台运行。")]),v._v(" "),_("p",[v._v("深拷贝与浅拷贝")]),v._v(" "),_("p",[v._v("浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递")]),v._v(" "),_("p",[v._v("深拷贝：基本数据类型值传递，对引用数据类型，创建一个新的对象并复制内容")]),v._v(" "),_("ol",{attrs:{start:"6"}},[_("li",[v._v("接口与抽象类的区别")])]),v._v(" "),_("p",[v._v("○接口只能声明方法，默认是public；而抽象类可声明方法，也可实现方法")]),v._v(" "),_("p",[v._v("○一个类实现接口时需要实现接口的所有方法，而抽象类不一定")]),v._v(" "),_("p",[v._v("○一个类可以实现多个接口，但最多只能继承一个抽象类")]),v._v(" "),_("p",[v._v("○接口中实例变量默认是final类型的，而抽象类中则不一定")]),v._v(" "),_("p",[v._v("○接口没有构造器，而抽象类可以有构造器，但两者都不能通过new来实例化对象")]),v._v(" "),_("p",[v._v("可以通过对应的子类来完成接口和抽象类的实例化。")]),v._v(" "),_("ol",{attrs:{start:"7"}},[_("li",[v._v("重载与重写的区别")])]),v._v(" "),_("p",[v._v("○重载指的是同一个类中，方法名相同，但是参数类型/个数/返回值/访问修饰符不同；")]),v._v(" "),_("p",[v._v("○重写指的是子类对父类允许访问的方法进行重写，方法名和参数列表必须相同；")]),v._v(" "),_("p",[v._v("○重写方法的修饰符范围要大于等于父类，但不能重写私有方法。")]),v._v(" "),_("ol",{attrs:{start:"8"}},[_("li",[v._v("Java面向对象的三大特性（封装、继承、多态）")])]),v._v(" "),_("p",[v._v("○封装：属性私有化，通过get、set方法提供外部访问的接口，保证了安全。")]),v._v(" "),_("p",[v._v("○继承：Java只能单继承，子类拥有父类所有方法和属性，但不能访问私有方法和私有属性，")]),v._v(" "),_("p",[v._v("子类可以对父类进行扩展；子类可以用自己的方式来重写父类的方法。")]),v._v(" "),_("p",[v._v("○多态：指的是一个引用变量到底指向哪个实例对象，以及调用哪个类的方法，必须在")]),v._v(" "),_("p",[v._v("​    程序运行时才清楚（三个必要条件：继承、重写、父类引用指向子类的对象）")]),v._v(" "),_("p",[v._v("​    例如：List list = new ArrayList();")]),v._v(" "),_("ol",{attrs:{start:"9"}},[_("li",[v._v("线程与进程的区别")])]),v._v(" "),_("p",[v._v("○运行问题：一个进程包含多个线程，线程在进程下运行")]),v._v(" "),_("p",[v._v("○干扰问题：进程之间不存在干扰，而运行多个线程则会产生干扰")]),v._v(" "),_("p",[v._v("○数据共享：进程间很难共享数据，但多个线程很容易共享数据")]),v._v(" "),_("p",[v._v("○内存共享：进程可对内存地址加锁，多个线程访问共享内存时需等别的线程释放锁")]),v._v(" "),_("p",[v._v("○资源消耗：进程比线程消耗更多的资源")]),v._v(" "),_("ol",{attrs:{start:"10"}},[_("li",[v._v("线程的状态（5种）")])]),v._v(" "),_("p",[v._v("○创建线程后，      进入初始状态NEW；")]),v._v(" "),_("p",[v._v("○执行start()后，   进入可运行状态RUNNABLE；")]),v._v(" "),_("p",[v._v("○获得cpu时间片， 进入运行状态RUNNING；")]),v._v(" "),_("p",[v._v("○线程暂停执行后，进入阻塞状态BLOCKED；")]),v._v(" "),_("p",[v._v("■同步阻塞：    在获取同步锁时，该锁已经被别的线程占用")]),v._v(" "),_("p",[v._v("■等待阻塞：    线程调用了wait()， 进入等待队列")]),v._v(" "),_("p",[v._v("■其他阻塞：    线程调用了sleep()，进入阻塞状态")]),v._v(" "),_("p",[v._v("○run()和main()结束后，进入死亡状态TERMINATED。")]),v._v(" "),_("ol",{attrs:{start:"11"}},[_("li",[v._v("并发与并行的区别")])]),v._v(" "),_("p",[v._v("○并发：指的是同一时间，   多个任务都在执行")]),v._v(" "),_("p",[v._v("○并行：指的是单位时间内，多个任务同时执行")]),v._v(" "),_("ol",{attrs:{start:"12"}},[_("li",[v._v("死锁的必要条件及解决方法")])]),v._v(" "),_("p",[v._v("死锁指的是：多个线程同时被阻塞，它们都在等待资源释放，导致程序无法正常停止")]),v._v(" "),_("p",[v._v("○互斥条件：    在任意时刻，资源都只被一个线程占用")]),v._v(" "),_("p",[v._v("○请求与保持：进程在请求资源时被阻塞，对已获得的资源保持不放")]),v._v(" "),_("p",[v._v("○不剥夺条件：进程已获得的资源在未使用完之前，不能被剥夺")]),v._v(" "),_("p",[v._v("○循环等待：   若干个进程形成一种头尾相接的循环等待资源关系")]),v._v(" "),_("p",[v._v("通过破坏请求与保持、不剥夺条件、循环等待条件来解决死锁问题")]),v._v(" "),_("p",[v._v("○破坏请求与保持：  一次性请求需要的所有资源；")]),v._v(" "),_("p",[v._v("○破坏不剥夺条件：  当申请资源失败时，释放自己拥有的资源；")]),v._v(" "),_("p",[v._v("○破坏循环等待条件：按一定的顺序来申请资源，并按反序释放资源")]),v._v(" "),_("ol",{attrs:{start:"13"}},[_("li",[v._v("sleep方法与wait方法的区别")])]),v._v(" "),_("p",[v._v("○两者都是让线程进入阻塞状态")]),v._v(" "),_("p",[v._v("○sleep方法不会释放锁，  而wait方法要释放锁")]),v._v(" "),_("p",[v._v("○sleep方法会自动唤醒，  而wait方法需要其他线程调用notify方法才能唤醒")]),v._v(" "),_("p",[v._v("○sleep常用于暂停执行，  而wait常用于线程间的通信")]),v._v(" "),_("ol",{attrs:{start:"14"}},[_("li",[v._v("Java的锁")])]),v._v(" "),_("p",[v._v("○公平锁：   多个线程按申请锁的顺序来获取锁")]),v._v(" "),_("p",[v._v("○非公平锁：不按顺序来获取锁，synchronized，也是一种非公平锁。")]),v._v(" "),_("p",[v._v("​    非公平锁的优点在于吞吐量比公平锁大，ReentrantLock默认是非公平锁")]),v._v(" "),_("p",[v._v("○可重入锁：又名递归锁，指同一个线程在外层方法获取锁的时候，在进入内层方法会")]),v._v(" "),_("p",[v._v("​    自动获取锁，可重入锁可一定程度避免死锁。synchronized也是可重入锁。")]),v._v(" "),_("p",[v._v("○独享锁：    该锁只能被一个线程持有，比如写锁")]),v._v(" "),_("p",[v._v("○共享锁：    该锁可以被多个线程持有，比如读锁")]),v._v(" "),_("p",[v._v("○互斥锁：    该锁只能被一个线程持有，ReentrantLock")]),v._v(" "),_("p",[v._v("○读写锁：    Java中的具体实现为，ReadWriteLock")]),v._v(" "),_("p",[v._v("○乐观锁：    认为对同一数据的并发操作不会发生修改，因此不加锁，而是添加版本号，")]),v._v(" "),_("p",[v._v("​    在更新时会判断版本号是否一致，适用于读操作多的应用场景。")]),v._v(" "),_("p",[v._v("○悲观锁：    认为对同一数据的并发操作会发生修改，因此需要加锁，认为不加锁一定会出问题，")]),v._v(" "),_("p",[v._v("​    适用于写操作多的应用场景。")]),v._v(" "),_("p",[v._v("○分段锁：    concurrentHashMap在JDK1.7前就是使用分段锁来实现的并发，1.8放弃了分段锁")]),v._v(" "),_("p",[v._v("​    而使用synchronized和CAS机制来实现并发控制。")]),v._v(" "),_("p",[v._v("○自旋锁：   指的是尝试获取锁的线程不会立即阻塞，而是通过循环的方式去获取锁，减少了线程")]),v._v(" "),_("p",[v._v("上下文切换的消耗，缺点是循环会消耗CPU。")]),v._v(" "),_("ol",{attrs:{start:"15"}},[_("li",[v._v("Synchronized使用及原理")])]),v._v(" "),_("p",[v._v("主要作用：解决多线程之间访问资源的同步性，保证任意时刻只有一个线程操作被修饰部分")]),v._v(" "),_("p",[v._v("○修饰实例方法：给对象实例加锁，进入同步方法需要获取当前对象实例的锁")]),v._v(" "),_("p",[v._v("○修饰静态方法：给当前类加锁，  进入同步方法需要获取当前类class的锁")]),v._v(" "),_("p",[v._v("○修饰代码块：    给指定对象/类加锁，synchronized(object)  synchronized(类.class)")]),v._v(" "),_("p",[v._v("实现原理：")]),v._v(" "),_("p",[v._v("○修饰方法时：只使用了ACC_SYNCHRONIZED标识来表示这是一个同步方法")]),v._v(" "),_("p",[v._v("○修饰代码块：使用的是monitorenter和monitorexit指令分别执行同步代码块的起始和结束位置")]),v._v(" "),_("p",[v._v("执行monitorenter时会获取对象的锁，锁的计数器为0表示可获取，获取以后将")]),v._v(" "),_("p",[v._v("计数器置为1。执行monitorexit指令后，将计数器置为0，表示已释放锁；若获取锁")]),v._v(" "),_("p",[v._v("失败则进入阻塞，等待释放锁。")]),v._v(" "),_("ol",{attrs:{start:"15"}},[_("li",[v._v("Synchronized锁升级")])]),v._v(" "),_("p",[v._v("无锁 --\x3e 偏向锁 --\x3e 轻量级锁  --\x3e 重量级锁")]),v._v(" "),_("p",[v._v("无锁：所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成")]),v._v(" "),_("p",[v._v("​    功，其他修改失败的线程会不断重试直到修改成功。")]),v._v(" "),_("p",[v._v("偏向锁：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid为空，JVM让其持有偏向锁，并将 threadid 设置为其线程 id（线程第一次进入，使用CAS来设置线程id），再次进入的时候会先判断 threadid 是否与其线程 id 一致（无需CAS了）")]),v._v(" "),_("p",[v._v("■如果一致则可以直接使用此对象，降低获取锁带来的性能开销。")]),v._v(" "),_("p",[v._v("■如果不一致，则升级偏向锁为轻量级锁")]),v._v(" "),_("p",[v._v("偏向锁 --\x3e 轻量级锁条件")]),v._v(" "),_("p",[v._v("■当线程a的偏向锁被第二个线程 b 访问时，偏向锁就会升级为轻量级锁")]),v._v(" "),_("p",[v._v("轻量级锁（自旋锁）当升级为轻量级锁后，线程 B 会通过自旋的形式尝试获取锁，线程不会阻塞。")]),v._v(" "),_("p",[v._v("轻量级锁  --\x3e 重量级锁条件")]),v._v(" "),_("p",[v._v("■当前只有1个等待线程通过自旋等待，当自旋超过一定的次数时，轻量级锁便会升级为重量级锁")]),v._v(" "),_("p",[v._v("■当有多个线程来访时，轻量级锁也会升级为重量级锁")]),v._v(" "),_("p",[v._v("重量级锁：指当有一个线程获取锁之后，其余所有等待线程都会处于阻塞状态")]),v._v(" "),_("p",[v._v("重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。")]),v._v(" "),_("p",[v._v("为什么要锁升级？")]),v._v(" "),_("p",[v._v("锁升级是为了减低了synchronized(初始设计就是重量级锁)带来的性能消耗，synchronized锁在线程运行到同步代码块的时候，让程序的运行级别从用户态切换到内核态，将消耗大量资源。")]),v._v(" "),_("p",[v._v("因此采用锁升级的方式来减少程序运行状态的切换。")]),v._v(" "),_("ol",{attrs:{start:"16"}},[_("li",[v._v("Lock锁与synchronized的区别")])]),v._v(" "),_("p",[v._v("○synchronized在JVM层面实现，            而Lock锁是一个接口；")]),v._v(" "),_("p",[v._v("○synchronized无法判断获取锁的状态， 而Lock锁可通过tryLock()判断是否获取锁；")]),v._v(" "),_("p",[v._v("○synchronized锁需要线程一直等待，     而Lock锁可以让线程中断去做别的事情；")]),v._v(" "),_("p",[v._v("○两者都是可重入的非公平锁，                 而Lock锁可实例为公平锁，new ReentrantLock(true)；")]),v._v(" "),_("p",[v._v("○Lock锁适合大量同步代码的同步问题，  而synchronized锁适合代码少量的同步问题")]),v._v(" "),_("p",[v._v("○synchronized自动释放锁，Lock锁必须在finally{}中调用unLock()才释放锁，否则出现死锁；")]),v._v(" "),_("p",[v._v("总结：资源竞争越激烈，Lock的性能就远远优于synchronized锁")]),v._v(" "),_("p",[v._v("集合部分")]),v._v(" "),_("ol",{attrs:{start:"17"}},[_("li",[_("p",[v._v("Java集合数据结构及线程安全")])]),v._v(" "),_("li",[_("p",[v._v("List集合（有序）：ArrayList和LinkedList")])])]),v._v(" "),_("p",[v._v("○ArrayList    底层是一个Object[]数组，可以自动扩容，线程不安全")]),v._v(" "),_("p",[v._v("○LinkedList  底层是双向链表，线程不安全")]),v._v(" "),_("p",[v._v("○Vector        底层是一个Object[]数组，线程安全，使用synchronized修饰方法")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("Set集合（不可重复）：HashSet、LinkedHashSet、TreeSet")])]),v._v(" "),_("p",[v._v("○HashSet             底层是通过HashMap实现的，线程不安全")]),v._v(" "),_("p",[v._v("○LinkedHashSet  通过LinkedHashMap实现的，线程不安全")]),v._v(" "),_("p",[v._v("○TreeSet              通过TreeMap实现，线程不安全")]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("Map集合（k搜索）：HashMap、LinkedHashMap、Hashtable、TreeMap、concurrentHashMap")])]),v._v(" "),_("p",[v._v("○HashMap：JDK1.7前数组+链表，JDK1.8数组+链表/红黑树（线程不安全）")]),v._v(" "),_("p",[v._v("​            当链表长度> 8 且 数组长度 > 64时转为红黑树")]),v._v(" "),_("p",[v._v("○LinkedHashMap：JDK1.7数组+链表，JDK1.8数组+链表/红黑树（不安全）")]),v._v(" "),_("p",[v._v("○Hashtable：哈希表，一个特殊的数组value=hash(key)，线程安全")]),v._v(" "),_("p",[v._v("○TreeMap: 红黑树，加入了排序（升序），遍历结果是已排序的，不安全")]),v._v(" "),_("p",[v._v("○concurrentHashMap：JDK1.7前数组+链表，JDK1.8数组+链表/红黑树")]),v._v(" "),_("p",[v._v("线程安全：JDK1.7通过分段锁实现，JDK1.8通过synchronized + CAS机制实现安全")]),v._v(" "),_("ol",{attrs:{start:"18"}},[_("li",[v._v("Java线程安全的集合")])]),v._v(" "),_("p",[v._v("○concurrentHashMap：JDK1.7用分段锁，1.8使用synchronized + CAS机制（自旋/乐观锁）")]),v._v(" "),_("p",[v._v("○Hashtable：方法使用了synchronized关键字修饰")]),v._v(" "),_("p",[v._v("○Vector：      方法使用了synchronized关键字修饰")]),v._v(" "),_("ol",{attrs:{start:"19"}},[_("li",[v._v("将List/Set/Map转为线程安全的集合")])]),v._v(" "),_("p",[v._v("○List list      = Collections.synchronizedList ( new ArrayList<>());")]),v._v(" "),_("p",[v._v("○Set set       = Collections.synchronizedSet ( new HashSet<>() );")]),v._v(" "),_("p",[v._v("○Map map  = Collections.synchronizedMap( new HashMap<>());")]),v._v(" "),_("ol",{attrs:{start:"20"}},[_("li",[v._v("CAS原理（Compare and Swap）")])]),v._v(" "),_("p",[v._v("实现原理：三个核心参数，内存地址V、旧的预期值A、待更新值B")]),v._v(" "),_("p",[v._v("​     当线程需要改变内存中变量值时，需要比较旧的预期值A和内存V中的值，若相同则代表")]),v._v(" "),_("p",[v._v("​     该变量未被其它线程修改，所以允许此次修改。")]),v._v(" "),_("p",[v._v("实现流程：")]),v._v(" "),_("p",[v._v("○首先，在while循环内，通过get方法获取变量的当前值A；")]),v._v(" "),_("p",[v._v("○volatile保证获取的值就是内存中的最新值，即实现数据的可见性；")]),v._v(" "),_("p",[v._v("○然后，计算更新以后的值B；最后进入CAS操作，比较预期值A和内存V中的值是否相同，")]),v._v(" "),_("p",[v._v("若相同则更新，否则继续循环判断，直到满足条件为止。")]),v._v(" "),_("p",[v._v("○这个过程就是CAS的自旋过程，这也说明CAS采用的是一种乐观锁。")]),v._v(" "),_("p",[v._v("CAS操作：通过本地方法compareAndSwapInt()实现，包含了CAS的三个关键参数：")]),v._v(" "),_("p",[v._v("valueOffset：内存地址 V、expect：旧的预期值 A、update：更新值 B")]),v._v(" "),_("p",[v._v("优点分析：可以保证变量操作的原子性；在并发量较小时，CAS比锁机制效率更高")]),v._v(" "),_("p",[v._v("缺点分析：")]),v._v(" "),_("p",[v._v("○存在ABA问题：线程1获得初始值为A，接着线程2将其修改为B，最后线程3又将其改回A，整个过")]),v._v(" "),_("p",[v._v("程都符合CAS检查要求，但实际已发\t生了变化，可能导致严重错误。")]),v._v(" "),_("p",[v._v("比如：小明存款100元，想要取出50，但在操作时一不小心提交了两次，开启了两个线程，两个线程都是获取当前值100，要更新为50；但此时线程1执行成功了，而线程2被阻塞了，此时账户余额为50；恰好这时小明的妈妈成功转入50元，余额为100，这时线程2才恢复运行，经比较，\t将余额更新为50。最终导致错误，余额应该为100。")]),v._v(" "),_("p",[v._v("○CPU开销大：在并发量较大时，大量线程更新失败时，会反复尝试更新，将消耗大量的CPU资源")]),v._v(" "),_("p",[v._v("○不保证代码块原子性：通过原子类AtomicInteger保证1个变量的原子性")]),v._v(" "),_("p",[v._v("解决ABA：在比较阶段增加一个版本号，当值和版本号都相同时，才允许更新数据")]),v._v(" "),_("ol",{attrs:{start:"21"}},[_("li",[v._v("ArrayList扩容机制")])]),v._v(" "),_("p",[v._v("○创建ArrayList时，初始化一个空数组，当调用add()添加元素时，才将容量扩为10；")]),v._v(" "),_("p",[v._v("○当元素个数超过10时，就调用grow方法进行扩容，新容量为原来的1.5倍；")]),v._v(" "),_("p",[v._v("○当新容量  > 数组的理论最大值，即Integer最大值 - 8时，则进行大容量分配；")]),v._v(" "),_("p",[v._v("○若最小容量>数组的理论最大值，则将新容量设为Integer最大值0x7ffffff， 否则扩为数组最大值。")]),v._v(" "),_("p",[v._v("○最后根据新容量，调用Arrays.copyOf()来复制一个新的数组进行扩容")]),v._v(" "),_("ol",{attrs:{start:"22"}},[_("li",[v._v("HashMap实现原理及扩容（重要）")])]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("JDK1.7前 数组+链表； JDK1.8后 数组+链表/红黑树")]),v._v(" "),_("p",[_("strong",[v._v("■")]),v._v("数组的每个元素都指向了每个链表的第一个节点")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("在第一次put元素的时候，会对数组进行初始化，默认大小为16")]),v._v(" "),_("p",[_("strong",[v._v("■")]),v._v("若指定了容量，则会把容量修改为2的幂次方。")]),v._v(" "),_("p",[v._v("扩容机制：")]),v._v(" "),_("p",[v._v("默认容量16，加载因子为0.75，当元素个数超过阈值时触发扩容")]),v._v(" "),_("p",[v._v("阈值 = 容量*加载因子（0.75），每次按2的幂次方进行扩容")]),v._v(" "),_("p",[v._v("如果要往HashMap中放1000个元素，又不想让HashMap不停的扩容，最好一开始就把容量设为")]),v._v(" "),_("p",[v._v("2048，设为1024不行，因为元素添加到七百多（1024*0.75）的时候还是会扩容。")]),v._v(" "),_("p",[v._v("为什么是0.75？")]),v._v(" "),_("p",[v._v("负载因子为1过高，则会导致查询效率降低；负载因子为0.5，存1M的数据需要2M的空间，所以空间利用率极低；因此折中一下，将负载因子设为0.75，此时空间利用率比较高，而且避免了相当多的Hash冲突，提升了空间效率。")]),v._v(" "),_("ol",{attrs:{start:"23"}},[_("li",[v._v("HashMap执行put()的流程")])]),v._v(" "),_("p",[v._v("hashMap.put(key, value) 的流程：")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("判断当前数组table是否空（长度为0，或者null）")]),v._v(" "),_("p",[v._v("■如果是则调用resize()方法进行初始化操作；")]),v._v(" "),_("p",[v._v("○根据Key计算Hash值得到下标，判断该节点是否为空；")]),v._v(" "),_("p",[v._v("■如果为空，创建节点将Value存入该节点；")]),v._v(" "),_("p",[v._v("■如果不为空，则判断Key是否相同")]),v._v(" "),_("p",[v._v("●如果Key相同，则替换为最新的Value（key和哈希值都相同，则为同一元素，更新值）")]),v._v(" "),_("p",[v._v("●如果Key不同，则判断是否为红黑树节点（此时key不同，哈希值相同，即哈希冲突）")]),v._v(" "),_("p",[v._v("○如果是，则调用putTreeVal() 以TreeNode的方式添加到table数组中；")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("如果不是，则遍历链表")]),v._v(" "),_("p",[v._v("■如果找到了相同的Key则替换Value；")]),v._v(" "),_("p",[v._v("■如果找不到则在链表最后插入，当链表长度超过8时，将链表转为红黑树。")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("判断是否需要扩容，数组长度 > 阈值（负载因子*容量）")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1283027/1630639027098-9edc20e3-bb83-4181-bb5a-069665945632.png?x-oss-process=image%2Fresize%2Cw_635%2Climit_0",alt:"image.png"}})]),v._v(" "),_("ol",{attrs:{start:"24"}},[_("li",[v._v("HashMap和Hashtable的区别")])]),v._v(" "),_("p",[v._v("扩容机制不一样")]),v._v(" "),_("p",[v._v("不指定容量初始值：")]),v._v(" "),_("p",[v._v("○HashMap默认初始化大小为16， 之后每次扩充，容量都变为原来的2倍")]),v._v(" "),_("p",[v._v("○Hashtable默认初始化大小为11，之后每次扩充，容量都变为原来的2n+1倍")]),v._v(" "),_("p",[v._v("指定容量初始值：")]),v._v(" "),_("p",[v._v("○Hashtable直接使用传入的初始容量大小；")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("[HashMap总是按照2的幂次方进行扩充（大量位操作，返回2次幂）](https://www.yuque.com/chenxiansen-nh0uj/clzots/lqoh2d#_2.9 HashMap 的⻓度为什么是2的幂次⽅)")]),v._v(" "),_("p",[v._v("比如，我设置容量为100，则返回128进行扩充，必须满足2的幂次方！")]),v._v(" "),_("p",[v._v("因为，哈希值范围太大，不是直接用作下标，而需要对数组长度lenth求余。因此，采用了位操作")]),v._v(" "),_("p",[v._v("的方式，使得 hash % lenth 等价于 hash&(lenth-1)，前提就是 lenth 必须为2的幂次方。")]),v._v(" "),_("p",[v._v("线程是否安全：         HashMap非线程安全，Hashtable线程安全，内部方法使用synchronized修饰")]),v._v(" "),_("p",[v._v("对空key空值的支持：HashMap 可以存空的key和value，但是空key只能有一个，空value可以多个；")]),v._v(" "),_("p",[v._v("而HashTable不允许空key和空value；")]),v._v(" "),_("p",[v._v("执行效率：                因为线程安全的问题，HashMap 效率更⾼。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1283027/1629170255836-5dc9dd61-7200-4597-b600-c1780ccb6e49.png",alt:"image.png"}})]),v._v(" "),_("ol",{attrs:{start:"25"}},[_("li",[v._v("HashMap和HashSet的区别")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("HashMap")]),v._v(" "),_("th",[v._v("HashSet")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("HashMap实现了Map接口")]),v._v(" "),_("td",[v._v("HashSet实现了Set接口")])]),v._v(" "),_("tr",[_("td",[v._v("HashMap存储键值对")]),v._v(" "),_("td",[v._v("HashSet仅存储对象")])]),v._v(" "),_("tr",[_("td",[v._v("调用put()方法添加元素")]),v._v(" "),_("td",[v._v("调用add()方法添加元素")])]),v._v(" "),_("tr",[_("td",[v._v("HashMap通过key计算hashcode值")]),v._v(" "),_("td",[v._v("HashSet使用成员对象来计算hashcode值")])])])]),v._v(" "),_("ol",{attrs:{start:"26"}},[_("li",[v._v("ConcurrentHashMap和Hashtable的区别")])]),v._v(" "),_("p",[v._v("主要体现在数据结构、实现线程安全方式的不一样：")]),v._v(" "),_("p",[v._v("数据结构：Hashtable采用数组 + 链表")]),v._v(" "),_("p",[v._v("​    JDK1.7 ConcurrentHashMap采用数组+链表，JDK1.8 采用数组+链表/红黑树；")]),v._v(" "),_("p",[v._v("实现线程安全")]),v._v(" "),_("p",[v._v("ConcurrentHashMap：JDK1.7分段锁，JDK1.8 synchronized+CAS")]),v._v(" "),_("p",[v._v("■JDK1.7 ConcurrentHashMap使用分段锁对整个桶数组进行分割分段，每一把锁只锁容器中的一部分数据，多线程访问容器里不同数据段中的数据，就不存在锁竞争，提高并发访问效率。")]),v._v(" "),_("p",[v._v("■在JDK1.8以后，摒弃了分段锁的方式，通过synchronized + CAS机制实现安全")]),v._v(" "),_("p",[v._v("■寻址时间复杂度由O(N)变为了O(logN)。因为，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发。")]),v._v(" "),_("p",[v._v("■Hashtable（全表锁）：使用synchronized来保证线程安全，效率非常低。当多个线程同时访")]),v._v(" "),_("p",[v._v("​     问同步方法时，可能会进入阻塞或者轮询状态，竞争十分激烈。")]),v._v(" "),_("ol",{attrs:{start:"27"}},[_("li",[v._v("双重校验锁实现单例模式（手撕）")])]),v._v(" "),_("p",[v._v("○创建单例对象：必用volatile修饰，禁止JVM指令重排，保证执行顺序和变量可见性")]),v._v(" "),_("p",[v._v("○双重校验锁：在同步块加锁的内外有两次对象为空的判断，因为可能有多个线程同时进入第一个")]),v._v(" "),_("p",[v._v("if 判断，如果不进行第二次 if 判断，则可能产生两个实例。")]),v._v(" "),_("p",[v._v("○通过两次校验后，直接创建单例对象，完成初始化。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1283027/1629170290741-2790a28a-9cb8-47e2-9cf3-8d1460e5d313.png",alt:"image.png"}})]),v._v(" "),_("ol",{attrs:{start:"28"}},[_("li",[v._v("转发与重定向的区别")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/png/1283027/1630654836267-a8f15ce2-f431-4536-92fd-460e889f2421.png",alt:"image.png"}})]),v._v(" "),_("p",[v._v("因为请求了两次，所以请求域中的数据会丢失！")]),v._v(" "),_("ol",{attrs:{start:"29"}},[_("li",[v._v("Post与Get的区别")])]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("GET请求在URL中传送的参数是有长度限制的，而POST没有。")]),v._v(" "),_("p",[v._v("○GET只接受ASCII字符，而POST没有限制。")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。")]),v._v(" "),_("p",[_("strong",[v._v("○")]),v._v("GET参数通过URL传递，POST放在Request body中。")]),v._v(" "),_("p",[v._v("○GET在浏览器回退时是无害的，而POST会再次提交请求。")]),v._v(" "),_("p",[v._v("○GET产生的URL地址可以被Bookmark，而POST不可以。")]),v._v(" "),_("p",[v._v("○GET请求会被浏览器主动cache，而POST不会，除非手动设置。")]),v._v(" "),_("p",[v._v("○GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。")])])}),[],!1,null,null,null);_.default=p.exports}}]);