(window.webpackJsonp=window.webpackJsonp||[]).push([[394],{1024:function(e,s,t){"use strict";t.r(s);var v=t(14),_=Object(v.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"一、简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、简介"}},[e._v("#")]),e._v(" 一、简介")]),e._v(" "),s("p",[e._v("Redis 是开源免费， key-value 内存数据库，主要解决高并发、大数据场景下，热点数据访问的性能问题，提供高性能的数据快速访问。项目中部分数据访问比较频繁，对下游 DB（例如 MySQL）造成服务压力，这时候可以使用缓存来提高效率。")]),e._v(" "),s("p",[e._v("Redis 的主要特点包括：")]),e._v(" "),s("ul",[s("li",[e._v("Redis数据存储在内存中，可以提高热点数据的访问效率")]),e._v(" "),s("li",[e._v("Redis 除了支持 key-value 类型的数据，同时还支持其他多种数据结构的存储；")]),e._v(" "),s("li",[e._v("Redis 支持数据持久化存储，可以将数据存储在磁盘中，机器重启数据将从磁盘重新加载数据；")])]),e._v(" "),s("p",[e._v("Redis 作为缓存数据库和 MySQL 这种结构化数据库进行对比。")]),e._v(" "),s("ul",[s("li",[e._v("从数据库类型上，Redis 是 NoSQL 半结构化缓存数据库， MySQL 是结构化关系型数据库；")]),e._v(" "),s("li",[e._v("从读写性能上，MySQL 是持久化硬盘存储，读写速度较慢， Redis 数据存储读取都在内存，同时也可以持久化到磁盘，读写速度较快；")]),e._v(" "),s("li",[e._v("从使用场景上，Redis 一般作为 MySQL 数据读取性能优化的技术选型，彼此配合使用。")])]),e._v(" "),s("h1",{attrs:{id:"二、redis-基本数据结构与实战场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、redis-基本数据结构与实战场景"}},[e._v("#")]),e._v(" 二、Redis 基本数据结构与实战场景")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("序号")]),e._v(" "),s("th",[e._v("数据结构")]),e._v(" "),s("th",[e._v("常用命令")]),e._v(" "),s("th",[e._v("命令实例")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("1")]),e._v(" "),s("td",[e._v("字符串")]),e._v(" "),s("td",[e._v("1.set：设置key对应的value值  "),s("br"),e._v("2.get：获取对应key的值，如不存在返回nil"),s("br"),e._v("3.setnx：只有设置的值不存在，才设置"),s("br"),e._v("4.setex：设置键值，并指定对应的有效期，SETEX key seconds value"),s("br"),e._v("5.mset/mget：一次设置/获取多个key的值"),s("br"),e._v("6.incr/decr：对key值进行增加/减去1操作")]),e._v(" "),s("td",[e._v('1.set name "tom"'),s("br"),e._v("2.get name   -------\x3e结果：tom"),s("br"),e._v('3.setnx name "jim"'),s("br"),e._v('4.setex name 10 "tom"'),s("br"),e._v('5.mset key1 "hh" key2 "kk"'),s("br"),e._v("6.incr/decr key1  -------\x3e+1/-1")])]),e._v(" "),s("tr",[s("td",[e._v("2")]),e._v(" "),s("td",[e._v("list")]),e._v(" "),s("td",[e._v("1.lpush/rpush：在key所对应的list左/右部添加一个元素"),s("br"),e._v("2.lrange/lindex：获取列表给定范围/位置的所有值"),s("br"),e._v("3.lset：设置list中指定下表元素的值")]),e._v(" "),s("td",[e._v("1.lpush listname value1; rpush listname value2"),s("br"),e._v("2.lrange listname 0 -1 获取列表所有元素"),s("br"),e._v("3.lset listname 1 valuex")])]),e._v(" "),s("tr",[s("td",[e._v("3")]),e._v(" "),s("td",[e._v("set")]),e._v(" "),s("td",[e._v("1.sadd：向名称为key的set添加元素"),s("br"),e._v("2.smembers：查看集合中的所有成员"),s("br"),e._v("3.spop：随机返回并删除set中一个元素"),s("br"),e._v("4.sdiff：返回所有set与第一个set的差集"),s("br"),e._v("5.sunion：返回给定集合并集")]),e._v(" "),s("td",[e._v("1.sadd wordset aa; sadd wordiest bb;"),s("br"),e._v("2.smembers wordset"),s("br"),e._v("3.spop wordset"),s("br"),e._v("4.sdiff wordset wordset1"),s("br"),e._v("5.sunion wordset wordset1")])]),e._v(" "),s("tr",[s("td",[e._v("4")]),e._v(" "),s("td",[e._v("hash")]),e._v(" "),s("td",[e._v("1.hset：设置一个hash的field的指定值，如果key 不存在先创建"),s("br"),e._v("2.hget：获取某个hash的某个filed值"),s("br"),e._v("3.hmset/hmget：批量设置/获取hash内容"),s("br"),e._v("4.hlen：返回hash 表中key的数量"),s("br"),e._v("5.hkeys/hvals：返回 hash 表中所有的key/value")]),e._v(" "),s("td",[e._v('1.hset user name"tom"'),s("br"),e._v("2.hget user name"),s("br"),e._v("3.hmget user name sex"),s("br"),e._v("4.hlen user"),s("br"),e._v("5.hkeys user/hvals user")])]),e._v(" "),s("tr",[s("td",[e._v("5")]),e._v(" "),s("td",[e._v("Sorted set")]),e._v(" "),s("td",[e._v("1.zadd：将一个带有给定分值的成员添加到有"),s("br"),e._v("集合里面"),s("br"),e._v("2.zrange：取出集合中的元素"),s("br"),e._v("3.zcard：返回集合中所有元素的个数")]),e._v(" "),s("td",[e._v("1.zadd key 1 hello"),s("br"),e._v("2.zrang key0-1"),s("br"),e._v("3.zcard key")])])])]),e._v(" "),s("ol",[s("li",[e._v("redis的数据结构可以理解为"),s("code",[e._v("Map")])]),e._v(" "),s("li",[e._v("字符串类型的数据结构可以理解为"),s("code",[e._v("Map")])]),e._v(" "),s("li",[e._v("list类型的数据结构可以理解为"),s("code",[e._v("Map>")])]),e._v(" "),s("li",[e._v("set类型的数据结构可以理解为"),s("code",[e._v("Map>")])]),e._v(" "),s("li",[e._v("hash类型的数据结构可以理解为"),s("code",[e._v("Map>")])])]),e._v(" "),s("h1",{attrs:{id:"三、-场景解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、-场景解析"}},[e._v("#")]),e._v(" 三、 场景解析")]),e._v(" "),s("h3",{attrs:{id:"_3-1-string-类型使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-string-类型使用场景"}},[e._v("#")]),e._v(" 3.1 String 类型使用场景")]),e._v(" "),s("p",[s("strong",[e._v("场景一：商品库存数")])]),e._v(" "),s("p",[e._v("从业务上，商品库存数据是热点数据，交易行为会直接影响库存。而 Redis 自身 String 类型提供了：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("incr key && decr key && incrby key increment && decrby key decrement\n")])])]),s("p",[e._v("set goods_id 10; 设置 id 为 good_id 的商品的库存初始值为 10；\ndecr goods_id; 当商品被购买时候，库存数据减 1。\n依次类推的场景：商品的浏览次数，问题或者回复的点赞次数等。这种计数的场景都可以考虑利用 Redis 来实现。")]),e._v(" "),s("p",[s("strong",[e._v("场景二：时效信息存储")])]),e._v(" "),s("p",[e._v("Redis 的数据存储具有自动失效能力。也就是存储的 key-value 可以设置过期时间：set(key, value, expireTime)。")]),e._v(" "),s("p",[e._v("比如，用户登录某个 App 需要获取登录验证码， 验证码在 30 秒内有效。那么我们就可以使用 String 类型存储验证码，同时设置 30 秒的失效时间。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    keys = redisCli.get(key);\n     if(keys != null)\n    {\n        return false;\n    }\n    else\n    {\n        sendMsg()\n        redisCli.set(keys,value,expireTime)\n    }\n")])])]),s("h3",{attrs:{id:"_3-2-list-类型使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-list-类型使用场景"}},[e._v("#")]),e._v(" 3.2 List 类型使用场景")]),e._v(" "),s("p",[e._v("list 是按照插入顺序排序的字符串链表。可以在头部和尾部插入新的元素（双向链表实现，两端添加元素的时间复杂度为 O(1)） 。")]),e._v(" "),s("p",[s("strong",[e._v("场景一：消息队列实现")])]),e._v(" "),s("p",[e._v("目前有很多专业的消息队列组件 Kafka、RabbitMQ 等。 我们在这里仅仅是使用 list 的特征来实现消息队列的要求。在实际技术选型的过程中，大家可以慎重思考。")]),e._v(" "),s("p",[e._v("list 存储就是一个队列的存储形式：")]),e._v(" "),s("p",[e._v("lpush key value; 在 key 对应 list 的头部添加字符串元素；\nrpop key;移除列表的最后一个元素，返回值为移除的元素。")]),e._v(" "),s("p",[s("strong",[e._v("场景二：最新上架商品")])]),e._v(" "),s("p",[e._v("在交易网站首页经常会有新上架产品推荐的模块， 这个模块是存储了最新上架前 100 名。")]),e._v(" "),s("p",[e._v("这时候使用 Redis 的 list 数据结构，来进行 TOP 100 新上架产品的存储。")]),e._v(" "),s("p",[e._v("Redis ltrim 指令对一个列表进行修剪（trim），这样 list 就会只包含指定范围的指定元素。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("ltrim key start stop\n")])])]),s("p",[e._v("start 和 stop 都是由 0 开始计数的，这里的 0 是列表里的第一个元素（表头），1 是第二个元素。")]),e._v(" "),s("p",[e._v("如下伪代码演示：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    //把新上架商品添加到链表里\n    ret = r.lpush(“new:goods", goodsId)\n    //保持链表 100 位\n    ret = r.ltrim("new:goods", 0, 99)\n    //获得前 100 个最新上架的商品 id 列表\n    newest_goods_list = r.lrange("new:goods", 0, 99)\n')])])]),s("h3",{attrs:{id:"_3-3-set-类型使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-set-类型使用场景"}},[e._v("#")]),e._v(" 3.3 set 类型使用场景")]),e._v(" "),s("p",[e._v("set 也是存储了一个集合列表功能。和 list 不同，set 具备去重功能。当需要存储一个列表信息，同时要求列表内的元素不能有重复，这时候使用 set 比较合适。与此同时，set 还提供的交集、并集、差集。")]),e._v(" "),s("p",[e._v("例如，在交易网站，我们会存储用户感兴趣的商品信息，在进行相似用户分析的时候， 可以通过计算两个不同用户之间感兴趣商品的数量来提供一些依据。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    //userid 为用户 ID ， goodID 为感兴趣的商品信息。 \n    sadd “user:userId” goodID； \n\n    sadd “user:101”, 1\n    sadd “user:101”, 2\n    sadd “user:102”, 1\n    Sadd “user:102”, 3\n\n    sinter “user:101” “user:101”\n")])])]),s("p",[e._v("获取到两个用户相似的产品， 然后确定相似产品的类目就可以进行用户分析。")]),e._v(" "),s("p",[e._v("类似的应用场景还有， 社交场景下共同关注好友， 相似兴趣 tag 等场景的支持。")]),e._v(" "),s("h3",{attrs:{id:"_3-4-hash-类型使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-hash-类型使用场景"}},[e._v("#")]),e._v(" 3.4 Hash 类型使用场景")]),e._v(" "),s("p",[e._v("Redis 在存储对象（例如：用户信息）的时候需要对对象进行序列化转换然后存储。")]),e._v(" "),s("p",[e._v("还有一种形式，就是将对象数据转换为 JSON 结构数据，然后存储 JSON 的字符串到 Redis。")]),e._v(" "),s("p",[e._v("对于一些对象类型，还有一种比较方便的类型，那就是按照 Redis 的 Hash 类型进行存储。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("hset key field value\n")])])]),s("p",[e._v("例如，我们存储一些网站用户的基本信息， 我们可以使用：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    hset user101 name “小明”\n    hset user101 phone “123456”\n    hset user101 sex “男”\n")])])]),s("p",[e._v("这样就存储了一个用户基本信息，存储信息有：{name : 小明， phone : “123456”，sex : “男”}")]),e._v(" "),s("p",[e._v("当然这种类似场景还非常多， 比如存储订单的数据，产品的数据，商家基本信息等。大家可以参考来进行存储选型。")]),e._v(" "),s("h3",{attrs:{id:"_3-5-sorted-set-类型使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-sorted-set-类型使用场景"}},[e._v("#")]),e._v(" 3.5 Sorted Set 类型使用场景")]),e._v(" "),s("p",[e._v("Redis sorted set 的使用场景与 set 类似，区别是 set 不是自动有序的，而 sorted set 可以通过提供一个 score 参数来为存储数据排序，并且是自动排序，插入既有序。")]),e._v(" "),s("p",[e._v("业务中如果需要一个有序且不重复的集合列表，就可以选择 sorted set 这种数据结构。")]),e._v(" "),s("p",[e._v("比如，商品的购买热度可以将购买总量 num 当做商品列表的 score，这样获取最热门的商品时就是可以自动按售卖总量排好序。")]),e._v(" "),s("p",[e._v("sorted set 适合有排序需求的集合存储场景。 大家可以思考一下自己负责的业务服务是否有可以使用的场景。")])])}),[],!1,null,null,null);s.default=_.exports}}]);