(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{1108:function(t,a,e){"use strict";e.r(a);var r=e(14),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_68-gateway工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_68-gateway工作流程"}},[t._v("#")]),t._v(" 68_Gateway工作流程")]),t._v(" "),a("p",[t._v("三大核心概念")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；\n2. Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由；\n3. Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。\n")])])]),a("p",[t._v("web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。")]),t._v(" "),a("p",[t._v("predicate就是我们的匹配条件；而fliter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了")]),t._v(" "),a("p",[a("strong",[t._v("Gateway工作流程")])]),t._v(" "),a("p",[a("img",{attrs:{src:e(587),alt:"image-20211229134758145"}})]),t._v(" "),a("p",[t._v("客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。")]),t._v(" "),a("p",[t._v("Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。")]),t._v(" "),a("p",[t._v('过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post"）执行业务逻辑。')]),t._v(" "),a("p",[t._v("Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。")]),t._v(" "),a("p",[t._v("核心逻辑：路由转发 + 执行过滤器链。")])])}),[],!1,null,null,null);a.default=n.exports},587:function(t,a,e){t.exports=e.p+"assets/img/20211229134758.0b1d2ca6.png"}}]);