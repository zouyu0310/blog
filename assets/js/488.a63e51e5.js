(window.webpackJsonp=window.webpackJsonp||[]).push([[488],{1154:function(t,a,r){"use strict";r.r(a);var s=r(14),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"redis流-stream"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis流-stream"}},[t._v("#")]),t._v(" Redis流(Stream)")]),t._v(" "),a("h3",{attrs:{id:"是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[t._v("#")]),t._v(" 是什么")]),t._v(" "),a("p",[t._v("Redis5.0 之前的痛点，Redis消息队列的2种方案：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("List实现消息队列，List实现方式其实就是点对点的模式")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/78.png",alt:""}})])]),t._v(" "),a("li",[a("p",[t._v("Pub/Sub")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"images/79.pub%E3%80%81sub.png",alt:""}})]),t._v(" "),a("p",[t._v("Redis5.0版本新增了一个更强大的数据结构---Stream")]),t._v(" "),a("p",[t._v("一句话：Stream流就是Redis版的MQ消息中间件+阻塞队列")]),t._v(" "),a("h3",{attrs:{id:"能干嘛"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#能干嘛"}},[t._v("#")]),t._v(" 能干嘛")]),t._v(" "),a("p",[t._v("实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠")]),t._v(" "),a("h3",{attrs:{id:"底层结构和原理说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#底层结构和原理说明"}},[t._v("#")]),t._v(" 底层结构和原理说明")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/80.png",alt:""}})]),t._v(" "),a("p",[t._v("$\\textcolor{blue}{一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容}$")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/81.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"基本命令理论简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本命令理论简介"}},[t._v("#")]),t._v(" 基本命令理论简介")]),t._v(" "),a("h5",{attrs:{id:"队列相关指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列相关指令"}},[t._v("#")]),t._v(" 队列相关指令")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/82.png",alt:""}})]),t._v(" "),a("h5",{attrs:{id:"消费组相关指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消费组相关指令"}},[t._v("#")]),t._v(" 消费组相关指令")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/83.png",alt:""}})]),t._v(" "),a("p",[t._v("XINFO GROUPS    打印消费组的详细信息")]),t._v(" "),a("p",[t._v("XINFO STREAM     打印stream的详细信息")]),t._v(" "),a("h5",{attrs:{id:"四个特殊符号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四个特殊符号"}},[t._v("#")]),t._v(" 四个特殊符号")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("- +")]),t._v(" "),a("th",[t._v("最小和最大可能出现的Id")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("$")]),t._v(" "),a("td",[t._v("$表示只消费新的消息，当前流中最大的Id，可用于将要到来的信息")])]),t._v(" "),a("tr",[a("td",[t._v(">")]),t._v(" "),a("td",[t._v("用于XREADGROUP命令，表示迄今还没有发送给组中使用者的信息，会更新消费者组的最后Id")])]),t._v(" "),a("tr",[a("td",[t._v("*")]),t._v(" "),a("td",[t._v("用于XADD命令，让系统自动生成Id")])])])]),t._v(" "),a("p",[t._v("$\\textcolor{red}{基本命令代码实操}$")]),t._v(" "),a("p",[t._v("Redis流实例演示")]),t._v(" "),a("h2",{attrs:{id:"队列相关命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列相关命令"}},[t._v("#")]),t._v(" 队列相关命令")]),t._v(" "),a("h3",{attrs:{id:"_1-xadd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-xadd"}},[t._v("#")]),t._v(" 1.XADD")]),t._v(" "),a("p",[t._v("添加消息到队列末尾，消息ID必须要比上一个ID大，默认用星号表示自动生成ID；* 用于XADD命令中，让系统自动生成ID；")]),t._v(" "),a("p",[t._v("XADD用于向Stream队列中添加消息，如果指定的Stream队列不存在，则该命令执行时会新建一个Stream队列")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/84.Stream-XADD.png",alt:""}})]),t._v(" "),a("p",[t._v("生成的消息ID，有两部分组成，毫秒时间戳-该毫秒内产生的第一条消息")]),t._v(" "),a("p",[t._v("// * 表示服务器自动生成MessageID(类似MySQL里面主键auto_increment)，后面顺序跟着一堆业务key/value")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("信息条目指的是序列号，在相同的毫秒下序列号从0开始递增，序列号是64位长度，理论上在同一毫秒内生成的数据量无法到达这个级别，因此不用担心序列号会不够用。milisecondsTime指的是Redis节点服务器的本地时间，如果存在当前的毫秒时间截比以前已经存在的数据的时间戳小的话(本地时间钟后跳)，那么系统将会采用以前相同的毫秒创建新的ID，也即redis 在增加信息条目时会检查当前 id 与上一条目的 id，自动纠正错误的情况，一定要保证后面的 id 比前面大，.个流中信息条目的ID必须是单调增的，这是流的基础。")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("客户端显示传入规则:"),a("br"),t._v("Redis对于ID有强制要求，格式必须是"),a("strong",[t._v("时间戳-自增Id")]),t._v("这样的方式，且后续ID不能小于前一个ID")])]),t._v(" "),a("tr",[a("td",[t._v("Stream的消息内容，也就是图中的Messaget它的结构类似Hash结构，以kev-value的形式存在")])])])]),t._v(" "),a("h3",{attrs:{id:"_2-xrange-key-start-end-count-count"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-xrange-key-start-end-count-count"}},[t._v("#")]),t._v(" 2.XRANGE key start end [COUNT count]")]),t._v(" "),a("p",[t._v("用于获取消息列表（可以指定范围），忽略删除的消息")]),t._v(" "),a("p",[t._v("start 表示开始值，-代表最小值")]),t._v(" "),a("p",[t._v("end 表示结束值，+代表最大值")]),t._v(" "),a("p",[t._v("count 表示最多获取多少个值")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/85.Stream-XRANGE.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_3-xrevrange-key-end-start-count-count"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-xrevrange-key-end-start-count-count"}},[t._v("#")]),t._v(" 3.XREVRANGE key end start [COUNT count]")]),t._v(" "),a("p",[t._v("根据ID降序输出")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/86.Stream-XREVRANGE.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_4-xdel-key-id-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-xdel-key-id-id"}},[t._v("#")]),t._v(" 4.XDEL key id [id ...]")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/87.Stream-XDEL.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_5-xlen-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-xlen-key"}},[t._v("#")]),t._v(" 5.XLEN key")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/88.Stream-XLEN.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_6-xtrim-key-maxlen-minid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-xtrim-key-maxlen-minid"}},[t._v("#")]),t._v(" 6.XTRIM key MAXLEN|MINID")]),t._v(" "),a("p",[t._v("用于对Stream的长度进行截取，如超长会进行截取")]),t._v(" "),a("p",[t._v("MAXLEN 允许的最大长度，对流进行修剪限制长度")]),t._v(" "),a("p",[t._v("MINID 允许的最小id，从某个id值开始比该id值小的将会被抛弃")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/89.Stream-xtrim.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_7-xread-count-count-block-milliseconds-streams-key-key-id-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-xread-count-count-block-milliseconds-streams-key-key-id-id"}},[t._v("#")]),t._v(" 7.XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]")]),t._v(" "),a("p",[t._v("可以读取多个key")]),t._v(" "),a("p",[a("strong",[t._v("用于获取消息(阻塞/非阻塞)")])]),t._v(" "),a("p",[t._v("​\t只会返回大于指定ID的消息，COUNT最多读取多少条消息；BLOCK是否以阻塞的方式读取消息，默认不阻塞，如果milliseconds设置为0，表示永远阻塞")]),t._v(" "),a("p",[a("strong",[t._v("非阻塞")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("$表特殊ID，表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil")])]),t._v(" "),a("li",[a("p",[t._v("0-0代表从最小的ID开始获取Stream中的消息，当不指定count，将会返回Stream中的所有消息，注意也可以使用0 (00/000也都是可以的)")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/90.png",alt:""}})])])]),t._v(" "),a("p",[a("strong",[t._v("阻塞")])]),t._v(" "),a("p",[a("img",{attrs:{src:"images/91.png",alt:""}})]),t._v(" "),a("p",[t._v("$\\textcolor{red}{小总结（类似Java里面的阻塞队列）}$")]),t._v(" "),a("p",[t._v("Stream的基础方法，使用XADD存入消息和XREAD循环阻塞读取消息的方式可以实现简易版的消息队列")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/92.png",alt:""}})]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"消费组相关指令-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消费组相关指令-2"}},[t._v("#")]),t._v(" 消费组相关指令")]),t._v(" "),a("h3",{attrs:{id:"_1-xgroup-create-key-group-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-xgroup-create-key-group-id"}},[t._v("#")]),t._v(" 1.XGROUP CREATE key group id|$")]),t._v(" "),a("p",[t._v("用于创建消费组")]),t._v(" "),a("p",[t._v("xgroup create mystream group $")]),t._v(" "),a("p",[t._v("xgroup create mystream groupB 0")]),t._v(" "),a("p",[t._v("$表示从Stream尾部开始消费")]),t._v(" "),a("p",[t._v("0表示从Stream头部开始消费")]),t._v(" "),a("p",[t._v("创建消费组的时候必须指定ID，ID为0表示从头开始消费，为$表示只消费新消息")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/93.Stream-xgroup.png",alt:""}}),t._v("''")]),t._v(" "),a("h3",{attrs:{id:"_2-xreadgroup-group-group-count-count-block-milliseconds-streams-key-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-xreadgroup-group-group-count-count-block-milliseconds-streams-key-id"}},[t._v("#")]),t._v(" 2.XREADGROUP GROUP group  [COUNT count] [BLOCK milliseconds] STREAMS key id")]),t._v(" "),a("p",[t._v('">"，表示从第一条尚未被消费的消息开始读取')]),t._v(" "),a("p",[a("img",{attrs:{src:"images/94.png",alt:""}})]),t._v(" "),a("p",[t._v("消费组groupA内的消费者consumer1从mystream消息队列中读取所有消息")]),t._v(" "),a("p",[t._v("但是，"),a("strong",[t._v("不同消费组")]),t._v("的消费者可以消费同一条消息")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/95.png",alt:""}})]),t._v(" "),a("p",[t._v("$\\textcolor{red}{消费组的目的？}$")]),t._v(" "),a("p",[t._v("让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分部的")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/96.png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"重点问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重点问题"}},[t._v("#")]),t._v(" 重点问题")]),t._v(" "),a("p",[t._v("基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息?")]),t._v(" "),a("p",[t._v('Streams 会自动使用内部队列(也称为 PENDING List)留存消费组里每个消费者读取的消息保底措施，直到消费者使用 XACK命令通知 Streams"消息已经处理完成”。\n消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成')]),t._v(" "),a("p",[a("img",{attrs:{src:"images/97.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_3-xpending"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-xpending"}},[t._v("#")]),t._v(" 3.XPENDING")]),t._v(" "),a("p",[t._v("查询每个消费组内所有消费组$\\textcolor{red}{[已读取、但尚未确认]}$的消息")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/98.Stream-XPENDING.png",alt:""}})]),t._v(" "),a("p",[t._v("查看某个消费组具体读取了那些数据")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/99.Stream-XPENDING.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_4-xack-key-group-id-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-xack-key-group-id-id"}},[t._v("#")]),t._v(" 4.XACK key group id [id...]")]),t._v(" "),a("p",[t._v("向消息队列确认消息处理已完成")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/100.Stream-XACK.jpg",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"xinfo-用于打印stream-consumer-group的详细信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xinfo-用于打印stream-consumer-group的详细信息"}},[t._v("#")]),t._v(" XINFO 用于打印Stream\\Consumer\\Group的详细信息")]),t._v(" "),a("p",[a("img",{attrs:{src:"images/101.Stream-XINFO.jpg",alt:""}})])])}),[],!1,null,null,null);a.default=e.exports}}]);