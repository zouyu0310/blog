(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{929:function(t,a,s){"use strict";s.r(a);var n=s(14),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"rabbitmq如何保证消息不丢失"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq如何保证消息不丢失"}},[t._v("#")]),t._v(" Rabbitmq如何保证消息不丢失")]),t._v(" "),a("h3",{attrs:{id:"_1-mq原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-mq原则"}},[t._v("#")]),t._v(" 1.mq原则")]),t._v(" "),a("p",[t._v("数据不能多，也不能少，不能多是说消息不能重复消费；不能少，就是说不能丢失数据。如果mq传递的是非常核心的消息，支撑核心的业务，那么这种场景是一定不能丢失数据的。")]),t._v(" "),a("h3",{attrs:{id:"_2-丢失数据场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-丢失数据场景"}},[t._v("#")]),t._v(" 2.丢失数据场景")]),t._v(" "),a("p",[t._v("丢数据一般分为三种，一种是mq把消息丢了，一种就是消费时将消息丢了,还有一种是生产者把消息丢了\n"),a("strong",[t._v("A:生产者弄丢了数据")]),t._v("\n生产者将数据发送到rabbitmq的时候，可能在传输过程中因为网络等问题而将数据弄丢了。\n"),a("strong",[t._v("B:rabbitmq自己丢了数据")]),t._v("\n如果没有开启rabbitmq的持久化，那么rabbitmq一旦重启，那么数据就丢了。所依必须开启持久化将消息持久化到磁盘，这样就算rabbitmq挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢失。除非极其罕见的情况，rabbitmq还没来得及持久化自己就挂了，这样可能导致一部分数据丢失。\n"),a("strong",[t._v("C:消费端弄丢了数据")]),t._v("\n如果一个消费者应用在消费的时候，刚消费到，还没处理,如进程挂了，比如重启了，rabbitmq认为你都消费了，这数据就丢了。")]),t._v(" "),a("h3",{attrs:{id:"_3-如何解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何解决"}},[t._v("#")]),t._v(" 3.如何解决")]),t._v(" "),a("p",[a("strong",[t._v("A:生产者丢失消息")])]),t._v(" "),a("p",[t._v("①：可以选择使用rabbitmq提供是事物功能，就是生产者在发送数据之前开启事物，然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会受到异常报错，这时就可以回滚事物，然后尝试重新发送；如果收到了消息，那么就可以提交事物。")]),t._v(" "),a("p",[t._v("特别说明：AMQP 协议中的事务仅仅是指生产者发送消息给 broker 这一系列流程处理的事务机制，并不包含消费端的处理流程。")]),t._v(" "),a("div",{staticClass:"language-scss extra-class"},[a("pre",{pre:!0,attrs:{class:"language-scss"}},[a("code",[t._v("  channel."),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("txSelect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//开启事物")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("try")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//发送消息")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Exection e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      channel."),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("txRollback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("；"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//回滚事物")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重新提交")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("**缺点：**rabbitmq事物已开启，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降。")]),t._v(" "),a("p",[t._v("②：可以开启confirm模式。在生产者哪里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如何写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//开启confirm")]),t._v("\n    channel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("confirm")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//发送成功回调")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ack")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("String messageId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 发送失败回调")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nack")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("String messageId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重发该消息")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("二者不同")]),t._v("\n事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后rabbitmq会回调告知成功与否。\n一般在生产者这块避免丢失，都是用confirm机制。\n"),a("strong",[t._v("B:rabbitmq自己弄丢了数据")]),t._v("\n设置消息持久化到磁盘。设置持久化有两个步骤：\n①创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里面的数据。\n②发送消息的时候将消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时rabbitmq就会将消息持久化到磁盘上。\n必须要同时开启这两个才可以。")]),t._v(" "),a("p",[t._v("而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前rabbitmq挂了，数据丢了，生产者收不到ack回调也会进行消息重发。\n"),a("strong",[t._v("C:消费者弄丢了数据")])]),t._v(" "),a("p",[t._v("rabbitmq有手动ack机制与自动ack机制来解决消费者弄丢数据：\n如果使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，使用手动ack，每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。")]),t._v(" "),a("p",[t._v("但是ack机制在异常情况下可能造成重复消费：当消费者异常断掉连接，但并未挂掉，broker 会得知， 此时broker 尚未获得 ack，那么消息会被重新放入其他队列，这样就导致数据被重复消费了。")]),t._v(" "),a("p",[t._v("应用层解决重复的方式：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("1.")]),t._v(" 专门的 Map 存储：用来存储每个消息的执行状态（用 msgid 区分），执行成功之后更新 Map，有另外消息重复消费的时候，读取 Map 数据判断 msgid 对应的执行状态，已消费则不执行。")]),t._v(" "),a("li",[a("strong",[t._v("2.")]),t._v(" 业务逻辑判断：消息执行完会更改某个实体状态，判断实体状态是否更新，如果更新，则不进行重复消费。")])]),t._v(" "),a("p",[t._v("总结：AMQP 提供的是“"),a("strong",[t._v("至少一次交付")]),t._v("”（at-least-once delivery），异常情况下，消息会被重复消费，此时业务要实现幂等性（重复消息处理）")])])}),[],!1,null,null,null);a.default=r.exports}}]);