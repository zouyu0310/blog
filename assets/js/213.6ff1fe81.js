(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{825:function(t,a,v){"use strict";v.r(a);var _=v(14),e=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-线程和进程有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-线程和进程有什么区别"}},[t._v("#")]),t._v(" 1. 线程和进程有什么区别？")]),t._v(" "),a("p",[t._v("线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。")]),t._v(" "),a("p",[a("strong",[t._v("根本区别")]),t._v("：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位")]),t._v(" "),a("p",[a("strong",[t._v("资源开销")]),t._v("：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。")]),t._v(" "),a("p",[a("strong",[t._v("包含关系")]),t._v("：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。")]),t._v(" "),a("p",[a("strong",[t._v("内存分配")]),t._v("：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的")]),t._v(" "),a("p",[a("strong",[t._v("影响关系")]),t._v("：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。")]),t._v(" "),a("p",[a("strong",[t._v("执行过程")]),t._v("：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行")]),t._v(" "),a("h2",{attrs:{id:"_2-创建线程的三种方式的对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-创建线程的三种方式的对比"}},[t._v("#")]),t._v(" 2. 创建线程的三种方式的对比？")]),t._v(" "),a("p",[a("strong",[t._v("1）采用实现Runnable、Callable接口的方式创建多线程。")])]),t._v(" "),a("p",[a("strong",[t._v("优势是")]),t._v("：")]),t._v(" "),a("p",[t._v("线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。")]),t._v(" "),a("p",[t._v("在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。")]),t._v(" "),a("p",[a("strong",[t._v("劣势是：")])]),t._v(" "),a("p",[t._v("编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。")]),t._v(" "),a("p",[a("strong",[t._v("2）使用继承Thread类的方式创建多线程")])]),t._v(" "),a("p",[a("strong",[t._v("优势是：")])]),t._v(" "),a("p",[t._v("编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。")]),t._v(" "),a("p",[a("strong",[t._v("劣势是：")])]),t._v(" "),a("p",[t._v("线程类已经继承了Thread类，所以不能再继承其他父类。")]),t._v(" "),a("p",[a("strong",[t._v("3）Runnable和Callable的区别")])]),t._v(" "),a("ul",[a("li",[t._v("Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。")]),t._v(" "),a("li",[t._v("Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。")]),t._v(" "),a("li",[t._v("Call方法可以抛出异常，run方法不可以。")]),t._v(" "),a("li",[t._v("运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。")])]),t._v(" "),a("h2",{attrs:{id:"_3-为什么要使用多线程呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么要使用多线程呢"}},[t._v("#")]),t._v(" 3. 为什么要使用多线程呢?")]),t._v(" "),a("ul",[a("li",[t._v("从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,"),a("strong",[t._v("线程间的切换和调度的成本远远小于进程")]),t._v("。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。")]),t._v(" "),a("li",[t._v("从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而"),a("strong",[t._v("多线程并发编程正是开发高并发系统的基础")]),t._v("，利用好多线程机制可以大大提高系统整体的并发能力以及性能。")])]),t._v(" "),a("p",[t._v("从计算机底层来说：")]),t._v(" "),a("ul",[a("li",[t._v("单核时代： "),a("strong",[t._v("在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率")]),t._v("。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。")]),t._v(" "),a("li",[t._v("多核时代:"),a("strong",[t._v("多核时代多线程主要是为了提高 CPU 利用率")]),t._v("。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。")])]),t._v(" "),a("h2",{attrs:{id:"_4-线程的状态流转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-线程的状态流转"}},[t._v("#")]),t._v(" 4. 线程的状态流转")]),t._v(" "),a("p",[t._v("线程的生命周期及五种基本状态：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://youzhixueyuan.com/blog/wp-content/uploads/2019/08/20190801212341_70574.jpg",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("Java线程具有五中基本状态")])]),t._v(" "),a("p",[a("strong",[t._v("1）新建状态（New）")]),t._v("：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();")]),t._v(" "),a("p",[a("strong",[t._v("2）就绪状态（Runnable）")]),t._v("：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；")]),t._v(" "),a("p",[a("strong",[t._v("3）运行状态（Running）")]),t._v("：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；")]),t._v(" "),a("p",[a("strong",[t._v("4）阻塞状态（Blocked）")]),t._v("：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：")]),t._v(" "),a("p",[t._v("1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；")]),t._v(" "),a("p",[t._v("2.同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；")]),t._v(" "),a("p",[t._v("3.其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。")]),t._v(" "),a("p",[a("strong",[t._v("5）死亡状态（Dead）")]),t._v("：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。")]),t._v(" "),a("h2",{attrs:{id:"_5-什么是线程死锁-如何避免死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-什么是线程死锁-如何避免死锁"}},[t._v("#")]),t._v(" 5. 什么是线程死锁?如何避免死锁?")]),t._v(" "),a("h3",{attrs:{id:"死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),a("ul",[a("li",[t._v("多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\n"),a("img",{attrs:{src:"http://blog-img.coolsen.cn/img/1583327022365_13.png",alt:""}})])]),t._v(" "),a("h3",{attrs:{id:"死锁必须具备以下四个条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁必须具备以下四个条件"}},[t._v("#")]),t._v(" 死锁必须具备以下四个条件：")]),t._v(" "),a("ul",[a("li",[t._v("互斥条件：该资源任意一个时刻只由一个线程占用。")]),t._v(" "),a("li",[t._v("请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。")]),t._v(" "),a("li",[t._v("不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。")]),t._v(" "),a("li",[t._v("循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。")])]),t._v(" "),a("h3",{attrs:{id:"如何避免线程死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免线程死锁"}},[t._v("#")]),t._v(" 如何避免线程死锁?")]),t._v(" "),a("p",[t._v("只要破坏产生死锁的四个条件中的其中一个就可以了")]),t._v(" "),a("ul",[a("li",[t._v("破坏互斥条件\n这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）")]),t._v(" "),a("li",[t._v("破坏请求与保持条件\n一次性申请所有的资源。")]),t._v(" "),a("li",[t._v("破坏不剥夺条件\n占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。")]),t._v(" "),a("li",[t._v("破坏循环等待条件\n靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。")]),t._v(" "),a("li",[t._v("锁排序法：（必须回答出来的点）\n指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？\n通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。")]),t._v(" "),a("li",[t._v("使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁")])]),t._v(" "),a("h2",{attrs:{id:"_6-常见的对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-常见的对比"}},[t._v("#")]),t._v(" 6. 常见的对比")]),t._v(" "),a("h3",{attrs:{id:"runnable-vs-callable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runnable-vs-callable"}},[t._v("#")]),t._v(" Runnable vs Callable")]),t._v(" "),a("ul",[a("li",[t._v("Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Callable 接口可以返回结果或抛出检查异常")]),t._v(" "),a("li",[t._v("Runnable 接口不会返回结果或抛出检查异常，")]),t._v(" "),a("li",[t._v("如果任务不需要返回结果或抛出异常推荐使用 Runnable接口，这样代码看起来会更加简洁")]),t._v(" "),a("li",[t._v("工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））")])]),t._v(" "),a("h3",{attrs:{id:"execute-vs-submit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#execute-vs-submit"}},[t._v("#")]),t._v(" execute() vs submit()")]),t._v(" "),a("ul",[a("li",[t._v("execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；")]),t._v(" "),a("li",[t._v("submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功（可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。）")])]),t._v(" "),a("h3",{attrs:{id:"shutdown-vsshutdownnow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shutdown-vsshutdownnow"}},[t._v("#")]),t._v(" shutdown()VSshutdownNow()")]),t._v(" "),a("ul",[a("li",[t._v("shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。")]),t._v(" "),a("li",[t._v("shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。\nshutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终")])]),t._v(" "),a("h3",{attrs:{id:"isterminated-vs-isshutdown"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isterminated-vs-isshutdown"}},[t._v("#")]),t._v(" isTerminated() VS isShutdown()")]),t._v(" "),a("ul",[a("li",[t._v("isShutDown 当调用 shutdown() 方法后返回为 true。")]),t._v(" "),a("li",[t._v("isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true")])]),t._v(" "),a("h2",{attrs:{id:"_7-sleep-方法和-wait-方法区别和共同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-sleep-方法和-wait-方法区别和共同点"}},[t._v("#")]),t._v(" 7. sleep() 方法和 wait() 方法区别和共同点?")]),t._v(" "),a("h3",{attrs:{id:"区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),a("ul",[a("li",[t._v("sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。")]),t._v(" "),a("li",[t._v("wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。")]),t._v(" "),a("li",[t._v("sleep 方法没有释放锁，而 wait 方法释放了锁 。")]),t._v(" "),a("li",[t._v("sleep 通常被用于暂停执行Wait 通常被用于线程间交互/通信")]),t._v(" "),a("li",[t._v("sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法")])]),t._v(" "),a("h3",{attrs:{id:"相同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同"}},[t._v("#")]),t._v(" 相同")]),t._v(" "),a("ul",[a("li",[t._v("两者都可以暂停线程的执行。")])]),t._v(" "),a("h2",{attrs:{id:"_8-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法"}},[t._v("#")]),t._v(" 8.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("new 一个 Thread，线程进入了新建状态; 调用start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，（调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。）这是真正的多线程工作。")]),t._v(" "),a("li",[t._v("直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n"),a("strong",[t._v("调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。")])])]),t._v(" "),a("h2",{attrs:{id:"_9-threadlocal是什么-有什么用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-threadlocal是什么-有什么用"}},[t._v("#")]),t._v(" 9.ThreadLocal是什么？有什么用？")]),t._v(" "),a("p",[t._v("ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。")]),t._v(" "),a("p",[t._v("简单说ThreadLocal就是一种以"),a("strong",[t._v("空间换时间")]),t._v("的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。")]),t._v(" "),a("h2",{attrs:{id:"_10-thread类中的yield方法有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-thread类中的yield方法有什么作用"}},[t._v("#")]),t._v(" 10. Thread类中的yield方法有什么作用？")]),t._v(" "),a("p",[t._v("Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。")]),t._v(" "),a("h2",{attrs:{id:"_11-java中的fork-join框架是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-java中的fork-join框架是什么"}},[t._v("#")]),t._v(" 11. Java中的fork join框架是什么？")]),t._v(" "),a("p",[t._v("fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。")]),t._v(" "),a("h2",{attrs:{id:"_12-synchronized和reentrantlock-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-synchronized和reentrantlock-的区别"}},[t._v("#")]),t._v(" 12. synchronized和ReentrantLock 的区别")]),t._v(" "),a("p",[a("strong",[t._v("1.两者都是可重入锁")])]),t._v(" "),a("p",[t._v("可重入锁：重入锁，也叫做递归锁，可重入锁指的是在一个线程中可以多次获取同一把锁，比如：\n一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁，\n两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。")]),t._v(" "),a("p",[a("strong",[t._v("2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API")])]),t._v(" "),a("ul",[a("li",[t._v("synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的")]),t._v(" "),a("li",[t._v("ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）")])]),t._v(" "),a("p",[a("strong",[t._v("3.ReentrantLock 比 synchronized 增加了一些高级功能")])]),t._v(" "),a("p",[t._v("相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）")]),t._v(" "),a("ul",[a("li",[t._v("等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。")]),t._v(" "),a("li",[t._v("ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。")]),t._v(" "),a("li",[t._v("ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，"),a("strong",[t._v("用ReentrantLock类结合Condition实例可以实现“选择性通知”")])])]),t._v(" "),a("p",[a("strong",[t._v("4.使用选择")])]),t._v(" "),a("ul",[a("li",[t._v("除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。")]),t._v(" "),a("li",[t._v("synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放")])]),t._v(" "),a("h2",{attrs:{id:"_13-谈谈volatile的使用及其原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-谈谈volatile的使用及其原理"}},[t._v("#")]),t._v(" 13. 谈谈volatile的使用及其原理")]),t._v(" "),a("p",[a("strong",[t._v("volatile的两层语义")]),t._v("：")]),t._v(" "),a("p",[t._v("1、volatile保证变量对所有线程的可见性：当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。")]),t._v(" "),a("p",[t._v("2、jdk1.5以后volatile完全避免了指令重排优化，实现了有序性。")]),t._v(" "),a("p",[a("strong",[t._v("volatile的原理:")])]),t._v(" "),a("p",[t._v("获取JIT（即时Java编译器，把字节码解释为机器语言发送给处理器）的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也是为什么JDK1.5以后可以使用双锁检测实现单例模式。")]),t._v(" "),a("p",[t._v("lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立即写入到主内存中，并且使得其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。")]),t._v(" "),a("p",[t._v("具体原理见这篇文章：https://www.javazhiyin.com/61019.html")]),t._v(" "),a("h2",{attrs:{id:"_14-synchronized-关键字和-volatile-关键字的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-synchronized-关键字和-volatile-关键字的区别"}},[t._v("#")]),t._v(" 14. synchronized 关键字和 volatile 关键字的区别")]),t._v(" "),a("ul",[a("li",[t._v("volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。")]),t._v(" "),a("li",[t._v("volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。实际开发中使用 synchronized 关键字的场景还是更多一些。")]),t._v(" "),a("li",[t._v("多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞")]),t._v(" "),a("li",[t._v("volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证")]),t._v(" "),a("li",[t._v("volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);