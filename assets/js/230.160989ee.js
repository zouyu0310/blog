(window.webpackJsonp=window.webpackJsonp||[]).push([[230],{840:function(t,a,_){"use strict";_.r(a);var v=_(14),s=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-解释一下什么是cap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-解释一下什么是cap"}},[t._v("#")]),t._v(" 1.解释一下什么是CAP？")]),t._v(" "),a("ul",[a("li",[t._v("Consistency：一致性就是在客户端任何时候看到各节点的数据都是一致的。")]),t._v(" "),a("li",[t._v("Availability：可用性就是在任何时刻都可以提供读写。")]),t._v(" "),a("li",[t._v("Partition Tolerance：分区容错性是在网络故障、某些节点不能通信的时候系统仍能继续工作。\n具体地讲在分布式系统中，在任何数据库设计中，一个Web应用最多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。\n"),a("img",{attrs:{src:"http://blog-img.coolsen.cn/img/801753-20151107213219867-1667011131.png",alt:"img"}})])]),t._v(" "),a("p",[t._v("AP（高可用&&分区容错）:")]),t._v(" "),a("p",[t._v("允许至少一个节点更新状态会导致数据不一致，即丧失了C性质（一致性）。会导致全局的数据不一致。")]),t._v(" "),a("p",[t._v("CP（一致&&分区容错）:")]),t._v(" "),a("p",[t._v("为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质（可用性）。分区同步会导致同步时间无限延长（也就是等数据同步完成之后才能正常访问）")]),t._v(" "),a("p",[t._v("CA（一致&&高可用）:")]),t._v(" "),a("p",[t._v("两个节点可以互相通信，才能既保证C（一致性）又保证A（可用性），这又会导致丧失P性质（分区容错性）。这样的话就分布式节点受阻，无法部署子节点,放弃了分布式系统的可扩展性。因为分布式系统与单机系统不同，它涉及到多节点间的通讯和交互，节点间的分区故障是必然发生的，所以在分布式系统中分区容错性是必须要考虑的。")]),t._v(" "),a("h2",{attrs:{id:"_2-什么分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么分布式事务"}},[t._v("#")]),t._v(" 2.什么分布式事务？")]),t._v(" "),a("p",[t._v("分布式事务服务（Distributed Transaction Service，DTS）是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。")]),t._v(" "),a("p",[t._v("CAP理论告诉我们在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的，所以我们只能在一致性和可用性之间进行权衡。")]),t._v(" "),a("p",[t._v("为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。")]),t._v(" "),a("h2",{attrs:{id:"_3-了解base理论吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-了解base理论吗"}},[t._v("#")]),t._v(" 3.了解BASE理论吗？")]),t._v(" "),a("p",[t._v("BASE理论指的是：")]),t._v(" "),a("ul",[a("li",[t._v("Basically Available（基本可用）")]),t._v(" "),a("li",[t._v("Soft state（软状态）")]),t._v(" "),a("li",[t._v("Eventually consistent（最终一致性）\nBASE理论是对CAP中的一致性和可用性进行一个权衡的结果，是对互联网大规模分布式系统的实践总结，强调可用性。")])]),t._v(" "),a("p",[t._v("理论的核心思想就是：基本可用（Basically Available）和最终一致性（Eventually consistent）。虽然无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。")]),t._v(" "),a("h2",{attrs:{id:"_4-实现分布式事务一致性-consistency-的方法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-实现分布式事务一致性-consistency-的方法有哪些"}},[t._v("#")]),t._v(" 4.实现分布式事务一致性（Consistency）的方法有哪些?")]),t._v(" "),a("p",[t._v("最著名的就是二阶段提交协议、三阶段提交协议和Paxos算法。")]),t._v(" "),a("p",[a("strong",[t._v("两阶段提交协议")])]),t._v(" "),a("ul",[a("li",[t._v("prepare(准备阶段)")])]),t._v(" "),a("p",[t._v("当开始事务调用的时候，事务处理器向事务执行者（有可能是数据库本身支持）发出命令，事务执行者进行prepare操作。\n当所有事务执行者都完成了prepare操作，就进行下一步行为。\n如果有一个事务执行者在执行prepare的时候失败了，那么通知事务处理器，事务处理器再通知所有的事务执行者执行回滚操作。")]),t._v(" "),a("ul",[a("li",[t._v("commit(提交阶段)")])]),t._v(" "),a("p",[t._v("当所有事务执行者都prepare成功以后，事务处理器会再次发送commit请求给事务执行者，所有事务执行者进行commit处理。\n当所有commit处理都成功了，那么事务执行结束。\n如果有一个事务执行者的commit处理不成功，这个时候就要通知事务处理器，事务处理器通知所有的事务执行者执行回滚(abort)操作。\n但是两阶段提交的诟病就是在于性能问题。比如由于执行链比较长，锁定资源的时间也变长了。所以在高性能的系统中都会避免使用二阶段提交。")])])}),[],!1,null,null,null);a.default=s.exports}}]);