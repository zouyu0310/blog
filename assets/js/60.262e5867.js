(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{526:function(r,e,o){r.exports=o.p+"assets/img/20200521205820.e7b0ecdc.png"},527:function(r,e,o){r.exports=o.p+"assets/img/20200521205949.a9ad64ca.png"},937:function(r,e,o){"use strict";o.r(e);var t=o(14),s=Object(t.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("ul",[e("li",[e("a",{attrs:{href:"#1-master%E5%92%8Cworker"}},[r._v("1. master和worker")])]),r._v(" "),e("li",[e("a",{attrs:{href:"#2-worker%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B7%A5%E4%BD%9C"}},[r._v("2. worker如何进行工作")])]),r._v(" "),e("li",[e("a",{attrs:{href:"#3-%E4%B8%80%E4%B8%AAmaster%E5%92%8C%E5%A4%9A%E4%B8%AAwoker%E6%9C%89%E5%A5%BD%E5%A4%84"}},[r._v("3. 一个master和多个woker有好处")])]),r._v(" "),e("li",[e("a",{attrs:{href:"#4-%E8%AE%BE%E7%BD%AE%E5%A4%9A%E5%B0%91%E4%B8%AAworker%E5%90%88%E9%80%82"}},[r._v("4. 设置多少个worker合适")])]),r._v(" "),e("li",[e("a",{attrs:{href:"#5-%E8%BF%9E%E6%8E%A5%E6%95%B0worker_connection"}},[r._v("5. 连接数worker_connection")])])]),r._v(" "),e("h1",{attrs:{id:"_1-master和worker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-master和worker"}},[r._v("#")]),r._v(" 1. master和worker")]),r._v(" "),e("p",[e("img",{attrs:{src:o(526),alt:""}})]),r._v(" "),e("h1",{attrs:{id:"_2-worker如何进行工作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-worker如何进行工作"}},[r._v("#")]),r._v(" 2. worker如何进行工作")]),r._v(" "),e("p",[e("img",{attrs:{src:o(527),alt:""}})]),r._v(" "),e("h1",{attrs:{id:"_3-一个master和多个woker有好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-一个master和多个woker有好处"}},[r._v("#")]),r._v(" 3. 一个master和多个woker有好处")]),r._v(" "),e("p",[r._v("首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。")]),r._v(" "),e("ol",[e("li",[r._v("可以使用nginx –s reload热部署，利用nginx进行热部署操作")]),r._v(" "),e("li",[r._v("每个woker是独立的进程，如果有其中的一个woker出现问题，其他woker独立的，继续进行争抢，实现请求过程，不会造成服务中断")])]),r._v(" "),e("h1",{attrs:{id:"_4-设置多少个worker合适"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-设置多少个worker合适"}},[r._v("#")]),r._v(" 4. 设置多少个worker合适")]),r._v(" "),e("p",[r._v("Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu 数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。")]),r._v(" "),e("p",[r._v("设置worker 数量: worker_processes 4 \twork 绑定 cpu(4 work 绑定 4cpu)。")]),r._v(" "),e("h1",{attrs:{id:"_5-连接数worker-connection"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-连接数worker-connection"}},[r._v("#")]),r._v(" 5. 连接数worker_connection")]),r._v(" "),e("p",[r._v("这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于 HTTP 请 求 本 地 资 源来 说 ， 能 够 支 持 的 最大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections *worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。")]),r._v(" "),e("p",[r._v("第一个：发送请求，占用了woker 的几个连接数？")]),r._v(" "),e("p",[r._v("答案：2或者4个")]),r._v(" "),e("p",[r._v("第二个：nginx有一个master，有四个woker，每个woker支持最大的连接数1024，支持的最大并发数是多少？")]),r._v(" "),e("p",[r._v("普通的静态访问最大并发数是： worker_connections * worker_processes /2，")]),r._v(" "),e("p",[r._v("而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/4。")])])}),[],!1,null,null,null);e.default=s.exports}}]);