(window.webpackJsonp=window.webpackJsonp||[]).push([[171],{765:function(t,a,r){"use strict";r.r(a);var e=r(14),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"使用视图-适用于mysql-5及之后的版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用视图-适用于mysql-5及之后的版本"}},[t._v("#")]),t._v(" 使用视图（适用于MySQL 5及之后的版本）")]),t._v(" "),a("h3",{attrs:{id:"视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#视图"}},[t._v("#")]),t._v(" 视图")]),t._v(" "),a("p",[t._v("例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT cust_name, cust_contact FROM customers, orders, orderitems\nWHERE customers.cust_id = orders.cust_id\nAND orderitems,order_num = orders.order_num\nAND prod_id = 'TNT2';\n#此查询用来检索订购了某个特定产品的客户。假如把整个查询包装成一个名为productcusotmers的虚拟表，则\nSELECT cust_name, cust_contact FROM productcustomers\nWHERE prod_id = 'TNT2';\n")])])]),a("p",[t._v("productcustomers是一个视图。")]),t._v(" "),a("h4",{attrs:{id:"为什么使用视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用视图"}},[t._v("#")]),t._v(" 为什么使用视图")]),t._v(" "),a("ul",[a("li",[t._v("重用SQL语句。")]),t._v(" "),a("li",[t._v("简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。")]),t._v(" "),a("li",[t._v("使用表的组成部分而不是整个表。")]),t._v(" "),a("li",[t._v("保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。")]),t._v(" "),a("li",[t._v("更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。")])]),t._v(" "),a("h4",{attrs:{id:"视图的规则和限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#视图的规则和限制"}},[t._v("#")]),t._v(" 视图的规则和限制")]),t._v(" "),a("ul",[a("li",[t._v("与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。")]),t._v(" "),a("li",[t._v("对于可以创建的视图数目没有限制。")]),t._v(" "),a("li",[t._v("为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。")]),t._v(" "),a("li",[t._v("视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。")]),t._v(" "),a("li",[t._v("ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。")]),t._v(" "),a("li",[t._v("视图不能索引，也不能有关联的触发器或默认值。")]),t._v(" "),a("li",[t._v("视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。")])]),t._v(" "),a("h3",{attrs:{id:"使用视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用视图"}},[t._v("#")]),t._v(" 使用视图")]),t._v(" "),a("ul",[a("li",[t._v("视图用CREATE VIEW语句来创建。")]),t._v(" "),a("li",[t._v("使用SHOW CREATE VIEW viewname；来查看创建视图的语句")]),t._v(" "),a("li",[t._v("用DROP删除视图，其语法为DROP VIEW viewname;")]),t._v(" "),a("li",[t._v("更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。")])]),t._v(" "),a("h4",{attrs:{id:"利用视图简化复杂的联结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用视图简化复杂的联结"}},[t._v("#")]),t._v(" 利用视图简化复杂的联结")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE VIEW productcustomers AS\nSELECT cust_name, cust_contact, prod_id\nFROM customers, orders, orderietms\nWHERE customers.cust_id = orders.cust_id\nAND orderitems.order_num = orders.order_num;\n")])])]),a("p",[t._v("创建可重用的视图：创建不受特定数据限制的视图是一种好办法。例如，上面创建的视图返回生产所有产品的客户而不仅仅是生产TNT2的客户。扩展视图的范围不仅使得它能被重用，而且甚至更有用。这样做不需要创建和维护多个类似视图。")]),t._v(" "),a("h4",{attrs:{id:"用视图重新格式化检索出的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用视图重新格式化检索出的数据"}},[t._v("#")]),t._v(" 用视图重新格式化检索出的数据")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT Concat(RTrim(vend_name), ' (', RTrim(vend_country), ')') AS vend_title\nFROM vendors\nORDER BY vend_name;\n")])])]),a("p",[t._v("现在，假如经常需要这个格式的结果。不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可。为把此语句转换为视图，可按如下进行：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE VIEW vendorlocations AS\nSELECT Concat(RTrim(vend_name), ' (', RTrim(vend_country), ')') AS vend_title\nFROM vendors\nORDER BY vend_name;\n")])])]),a("p",[t._v("这条语句使用与以前的SELECT语句相同的查询创建视图。为了检索出以创建所有邮件标签的数据，可如下进行：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT *\nFROM vendorlocations;\n")])])]),a("h4",{attrs:{id:"用视图过滤不想要的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用视图过滤不想要的数据"}},[t._v("#")]),t._v(" 用视图过滤不想要的数据")]),t._v(" "),a("p",[t._v("例：排除没有电子邮件地址的用户")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE VIEW customeremaillist AS\nSELECT cust_id, cust_name, cust_email\nFROM customers\nWHERE cust_email IS NOT NULL;\n\nSELECT * FROM customeremaillist;\n")])])]),a("h4",{attrs:{id:"使用视图与计算字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用视图与计算字段"}},[t._v("#")]),t._v(" 使用视图与计算字段")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price\nFROM orderitems\nWHERE order_num = 20005;\n#将其转换为视图\nCREATE VIEW orderitemsexpanded AS\nSELECT order_num, prod_id, quantity, item_price, quantity*item_price AS expanded_price\nFROM orderitems;\n\nSELECT *\nFROM orderitemsexpanded\nWHERE order_num = 20005;\n")])])]),a("h4",{attrs:{id:"更新视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新视图"}},[t._v("#")]),t._v(" 更新视图")]),t._v(" "),a("p",[t._v("视图的数据能否更新视情况而定。")]),t._v(" "),a("p",[t._v("通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。 但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：")]),t._v(" "),a("ul",[a("li",[t._v("分组（使用GROUP BY和HAVING）；")]),t._v(" "),a("li",[t._v("联结；")]),t._v(" "),a("li",[t._v("子查询；")]),t._v(" "),a("li",[t._v("并；")]),t._v(" "),a("li",[t._v("聚集函数（Min()、Count()、Sum()等）；")]),t._v(" "),a("li",[t._v("DISTINCT；")]),t._v(" "),a("li",[t._v("导出（计算）列。")])]),t._v(" "),a("h2",{attrs:{id:"使用存储过程-适用于mysql5及之后的版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用存储过程-适用于mysql5及之后的版本"}},[t._v("#")]),t._v(" 使用存储过程（适用于MySQL5及之后的版本）")]),t._v(" "),a("h3",{attrs:{id:"存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储过程"}},[t._v("#")]),t._v(" 存储过程")]),t._v(" "),a("p",[t._v("存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。")]),t._v(" "),a("h3",{attrs:{id:"为什么使用存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用存储过程"}},[t._v("#")]),t._v(" 为什么使用存储过程")]),t._v(" "),a("ul",[a("li",[t._v("通过把处理封装在容易使用的单元中，简化复杂的操作（正如前面例子所述）。")]),t._v(" "),a("li",[t._v("由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。 这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能 性就越大。防止错误保证了数据的一致性。")]),t._v(" "),a("li",[t._v("简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。\n这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。")]),t._v(" "),a("li",[t._v("提高性能。因为使用存储过程比使用单独的SQL语句要快。")]),t._v(" "),a("li",[t._v("存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可以看到。）\n换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷。")])]),t._v(" "),a("h3",{attrs:{id:"使用存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用存储过程"}},[t._v("#")]),t._v(" 使用存储过程")]),t._v(" "),a("h4",{attrs:{id:"执行存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行存储过程"}},[t._v("#")]),t._v(" 执行存储过程")]),t._v(" "),a("p",[t._v("MySQL称存储过程的执行为调用，因此，MySQL执行存储过程的语句为CALL\n例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CALL productpricing(\n\t\t\t\t\t@pricelow.\n                    @pricehigh,\n                    @irceaverage);\n")])])]),a("p",[t._v("其中，执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。")]),t._v(" "),a("h4",{attrs:{id:"创建存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建存储过程"}},[t._v("#")]),t._v(" 创建存储过程")]),t._v(" "),a("p",[t._v("例：返回产品平均价格的存储过程")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE priductpricing()\nBEGIN\n\tSELECT Avg(prod_price) AS priceaverage\n    FROM priducts;\nEND;\n")])])]),a("p",[t._v("使用存储过程：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CALL priductpricing();\n")])])]),a("h5",{attrs:{id:"mysql命令行客户机的分隔符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql命令行客户机的分隔符"}},[t._v("#")]),t._v(" mysql命令行客户机的分隔符")]),t._v(" "),a("p",[t._v("默认的MySQL语句分隔符为';'。mysql命令行实用程序也使用';'作为语句分隔符。如果命令行实用程序要解释存储过程自身内的';'字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。\n解决办法是临时更改命令行实用程序的语句分隔符，如下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("DELIMTER//\n\nCREATE PROCEDURE productpricing()\nBEGIN\n\tSELECT Avg(prod_price) AS priceaverage\n    FROM products;\nEND//\n\nDELIMITER ;\n\n\n-- 其中，DELIMITER//告诉命令行实用程序使用//作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为END//而不是END;。这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符，可使用DELIMITER ;。除\\符号外，任何字符都可以用作语句分隔符。\n")])])]),a("h4",{attrs:{id:"删除存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除存储过程"}},[t._v("#")]),t._v(" 删除存储过程")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("DROP PROCEDURE productpricing;\n")])])]),a("p",[t._v("仅当存在时删除使用"),a("code",[t._v("DROP PROCEDURE IF EXISTS")])]),t._v(" "),a("h4",{attrs:{id:"使用参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用参数"}},[t._v("#")]),t._v(" 使用参数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE productpricing(\n\tOUT pl DECIMAL(8,2),\n    OUT ph DECIMAL(8,2),\n    OUT pa DECIMAL(8,2)\n)\nBEGIN\n\tSELECT Min(prid_price)\n    INTO pl\n    FROM products;\n    SELECT Max(prod_price)\n    INTO ph\n    FROM products;\n    SELECT AVG(prod_price)\n    INTO pa\n    FROM prodcts;\nEND;\n")])])]),a("p",[t._v("此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。")]),t._v(" "),a("p",[t._v("为调用此修改过的存储过程，必须指定3个变量名，如下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CALL productpricing(@pricelow,\n\t\t\t\t\t@pricehigh,\n                    @priceaverage);\n#为了显示检索出的产品价格，可如下进行\nSELECT @priceaverage；\n#为了获得3个值，可以使用如下语句\nSELECT @pricehigh, @pricelow, @priceaverage;\n")])])]),a("p",[t._v("例：使用IN和OUT参数，ordertotal接收订单号并返回该订单的合计。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE ordertotal(\n\tIN onumber INT,\n    OUT ototal DECIMAL(8,2)\n)\nBEGIN\n\tSELECT Sum(item_price*quantity)\n    FROM orderitems\n    WHERE order_num = onumber\n    INTO ototal;\nEND;\n\n#调用:必须传递两个参数，1为订单号，2为包含计算出来的合计的变量名\nCALL ordertotal(20005, @total);\n\n#显示合计\nSELECT @total;\n")])])]),a("h4",{attrs:{id:"建立只能存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立只能存储过程"}},[t._v("#")]),t._v(" 建立只能存储过程")]),t._v(" "),a("p",[t._v("例：获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客")]),t._v(" "),a("ul",[a("li",[t._v("获得合计")]),t._v(" "),a("li",[t._v("把营业税有条件地添加到合计")]),t._v(" "),a("li",[t._v("返回合计")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-- Name: ordertotal\n-- Parameters: onumber = order number\n--             taxable = 0 if not taxable, 1 if taxable\n--             ototal  = order total variable\n\nCREATE PROCEDURE ordertotal(\n\tIN onumber TNT,\n    IN taxable BOOLEAN,\n    OUT ototal DECIMAL(8,2)\n)COMMENT 'Obtain order total, optionally adding tax'\nBEGIN\n    -- DECLARE variable for total\n    DECLARE total DECIMAL (8,2);\n    -- DECLARE tax percentage\n    DECLARE taxrate INT DEFAULT 6;\n\n    -- Get the order total\n    SELECT Sum(item_price*quantity)\n    FROM orderitems\n    WHERE order_num = onumber\n    INTO total;\n\n    -- Is this taxable?\n    IF taxable THEN\n    \t-- Yes, so add taxrate to the total\n        SELECT total +(total/100*taxrate) INTO total;\n    END IF;\n\n    --And finally, save to our variable\n    SELECT total INTO ototal;\nEND;\n\n--试验\nCALL ordertotal(20005, 0, @total);\nSELECT @total;\n\nCALL ordertotal(20005, 1, @total);\nSELECT @total;\n\n")])])]),a("p",[t._v("此存储过程有很大的变动。首先，增加了注释（前面放置--）。在存储过程复杂性增加时，这样做特别重要。添加了另外一个参数taxable，它是一个布尔值（如果要增加税则为真，否则为假）。在存储过程体中，用DECLARE语句定义了两个局部变量。DECLARE要求指定变量名和数据类型，它也支持可选的默认值（这个例子中的taxrate的默 认被设置为6%）。SELECT语句已经改变，因此其结果存储到total（局部变量）而不是ototal。IF语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量total。最后，用另一SELECT语句将total（它增加或许不增加营业税）保存到ototal。\n本例子中的存储过程在CREATE PROCEDURE语句中包含了一个COMMENT值。它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示")]),t._v(" "),a("h4",{attrs:{id:"检查存储过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查存储过程"}},[t._v("#")]),t._v(" 检查存储过程")]),t._v(" "),a("p",[t._v("显示用来创建一个存储过程的CREATE语句，使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SHOW CREATE PROCEDURE ordertotal;\n")])])]),a("p",[t._v("为获得包括何时、由谁创建等详细信息的存储过程列表，使用"),a("code",[t._v("SHOW PRODUCEDURE STATUS")]),t._v(" "),a("code",[t._v("SHOW PROCEDURE STATUS")]),t._v("列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SHOW PROCEDURE STATUS LIKE 'ordertotal';\n")])])]),a("h2",{attrs:{id:"使用游标-适用于mysql5及以上版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用游标-适用于mysql5及以上版本"}},[t._v("#")]),t._v(" 使用游标（适用于MySQL5及以上版本）")]),t._v(" "),a("p",[t._v("有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。\nMySQL游标只能用于存储过程（和函数）")]),t._v(" "),a("h3",{attrs:{id:"使用游标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用游标"}},[t._v("#")]),t._v(" 使用游标")]),t._v(" "),a("p",[t._v("使用游标涉及几个明确的步骤。")]),t._v(" "),a("ul",[a("li",[t._v("在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。")]),t._v(" "),a("li",[t._v("一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。")]),t._v(" "),a("li",[t._v("对于填有数据的游标，根据需要取出（检索）各行。")]),t._v(" "),a("li",[t._v("在结束游标使用时，必须关闭游标。")])]),t._v(" "),a("h4",{attrs:{id:"创建游标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建游标"}},[t._v("#")]),t._v(" 创建游标")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE processorders()\nBEGIN\n\tDECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\nEND;\n")])])]),a("p",[t._v("这个存储过程并没有做很多事情，DECLARE语句用来定义和命名游标，这里为ordernumbers。存储过程处理完成后，游标就消失（因为它局限于存储过程）。")]),t._v(" "),a("h4",{attrs:{id:"打开和关闭游标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打开和关闭游标"}},[t._v("#")]),t._v(" 打开和关闭游标")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("--打开游标\nOPEN ordernumbers;\n--处理完成后，应当使用下句关闭游标\nCLOSE ordernumbers;\n")])])]),a("p",[t._v("CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭\nMySQL会在达到END语句时自动关闭它")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE processorders()\nBEGIN\n\t-- Declare the cursor\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELCET order_num FROM orders;\n\n    -- Open the cursor\n    OPEN ordernumbers;\n\n    --Close the cursor\n    CLOSE ordernumbers;\n\nEND;\n")])])]),a("p",[t._v("这个存储过程声明、打开和关闭一个游标，但对检索出的数据什么也没做。")]),t._v(" "),a("h4",{attrs:{id:"使用游标数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用游标数据"}},[t._v("#")]),t._v(" 使用游标数据")]),t._v(" "),a("p",[t._v("例：从游标中检索单个行")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE processorders()\nBEGIN\n\t-- Declare local variables\n    DECLARE o INT;\n\n    -- Declare the cursor\n    DECLARE orderumbers CURSOR\n    FRO\n    SELECT order_num FROM orders;\n\n    -- Open the cursor\n    OPEN ordernumbers;\n\n\t-- Get order number\n    FETCH ordernumbers INTO o;\n\n\t-- Close the cursor\n    CLOSE ordernumbers;\n\nEND;\n")])])]),a("p",[t._v("其中FETCH用来检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明的变量中。对检索出的数据不做任何处理。")]),t._v(" "),a("p",[t._v("例：循环检索数据，从第一行到最后一行")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE processorders()\nBEGIN\n\t--Declare local variables\n    DECLARE done BOOLEAN DEFAULT 0;\n    DECLARE o INT;\n\n    --Declare the cursor\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\n\n\t--Declare continue handler\n    DECLARE CONTINUE HANDLER FRO SQLSTATE '02000' SET done=1;\n\n\t--Open the cursor\n    OPEN ordernumbers;\n\n\t--Loop through all rows\n    REPEAT\n    \t--Get order numbers\n        FETCH ordernumbers INTO o;\n    --End of loop\n    UNTIL done END REPEAT;\n    --CLose the cursor\n    CLOSE ordernumbers;\nEND;\n")])])]),a("p",[t._v("这个例子使用FETCH检索当前order_num到声明的名为o的变量中。但与前一个例子不一样的是，这个例子中的FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。")]),t._v(" "),a("p",[t._v("使用以下语句将done在结束时设置为真：\n"),a("code",[t._v("DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1")])]),t._v(" "),a("p",[t._v("这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里，它指出当SQLSTATE '02000'出现时，SET done=1。SQLSTATE '02000'是一个未找到条件，当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。")]),t._v(" "),a("p",[t._v("例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE PROCEDURE processorders()\nBEGIN\n\t--Declare local variables\n    DECLARE done BOOLEAN DEFAULT 0;\n    DECLARE o INT;\n    DECLARE t DECIMAL(8,2);\n    --Declare the cursor\n    DECLARE ordernumbers CURSOR\n    FOR SELECT order_num FROM orders;\n    --Declare continue handler\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;\n    --Create a table to store the results\n    CREATE TABLE IF NOT EXISTS ordertotals\n    \t(order_num INT, total DECIMAL(8,2));\n    --Open the cursor\n    OPEN ordernumbers;\n    --Loop through all rows\n    REPEAT\n    \t--Get order number\n        FETCH ordernumbers INTO o;\n        --Get the total for this order\n        CALL ordertoal(o, 1, t);\n        --Insert order and total into ordertotals\n        INSERT INTO ordertotals(order_num, total)\n        VALUES(o,t);\n    --End of loop\n    UNTIL done END REPEAT;\n    --Close the cursor\n    CLOSE ordernumbers;\nEND;\n")])])]),a("p",[t._v("在这个例子中，增加了另一个名为t的变量（存储每个订单的合计）。此存储过程还在运行中创建了一个新表（如果它不存在的话），名为ordertotals。这个表将保存存储过程生成的结果。FETCH像以前一样取每个order_num，然后用CALL执行另一个存储过程来计算每个订单的带税的合计（结果存储到t）。最后，用INSERT保存每个订单的订单号和合计。\n次存储过程不返回数据\n可以用"),a("code",[t._v("SELECT * FROM ordertotals;")]),t._v("查看该表")]),t._v(" "),a("h2",{attrs:{id:"使用触发器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用触发器"}},[t._v("#")]),t._v(" 使用触发器")]),t._v(" "),a("p",[t._v("想要某条语句（或某些语句）在事件发生时自动执行\n触发器是MySQL响应一下任意语句而自动执行的一条MySQL语句")]),t._v(" "),a("ul",[a("li",[t._v("DELETE")]),t._v(" "),a("li",[t._v("INSERT")]),t._v(" "),a("li",[t._v("UPDATE\n其他MySQL语句不支持触发器")])]),t._v(" "),a("h3",{attrs:{id:"创建触发器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建触发器"}},[t._v("#")]),t._v(" 创建触发器")]),t._v(" "),a("p",[t._v("需要")]),t._v(" "),a("ul",[a("li",[t._v("唯一的触发器名")]),t._v(" "),a("li",[t._v("触发器关联的表")]),t._v(" "),a("li",[t._v("触发器应该响应的活动")]),t._v(" "),a("li",[t._v("触发器合适执行")])]),t._v(" "),a("p",[t._v("使用CREATE TRIGGER语句创建。例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE TRIGGER newproduct ALTER INSERT ON products\nFOR EACH ROW SELECT 'Product added';\n")])])]),a("p",[t._v("CREATE TRIGGER用来创建名为newproduct的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product added将对每个插入的行显示一次。")]),t._v(" "),a("p",[t._v("只有表支持触发器，视图不支持。")]),t._v(" "),a("p",[t._v("每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE前后）单一触发器不能与多个事件或多个表关联。")]),t._v(" "),a("h3",{attrs:{id:"删除触发器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除触发器"}},[t._v("#")]),t._v(" 删除触发器")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("DROP TRIGGER newproduct;\n")])])]),a("h3",{attrs:{id:"使用触发器-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用触发器-2"}},[t._v("#")]),t._v(" 使用触发器")]),t._v(" "),a("h4",{attrs:{id:"insert触发器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#insert触发器"}},[t._v("#")]),t._v(" INSERT触发器")]),t._v(" "),a("p",[t._v("INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：")]),t._v(" "),a("ul",[a("li",[t._v("在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；")]),t._v(" "),a("li",[t._v("在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；")]),t._v(" "),a("li",[t._v("对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。")])]),t._v(" "),a("p",[t._v("例：确定新值生成")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE TRIGGER neworder AFTER INSERT ON orders\nFOR EACH ROW SELECT NEW.order_num;\n")])])]),a("p",[t._v("此代码创建一个名为neworder的触发器，它按照AFTER INSERT ON orders执行。在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。")]),t._v(" "),a("h4",{attrs:{id:"delete触发器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delete触发器"}},[t._v("#")]),t._v(" DELETE触发器")]),t._v(" "),a("p",[t._v("DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两 点：")]),t._v(" "),a("ul",[a("li",[t._v("在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；")]),t._v(" "),a("li",[t._v("OLD中的值全都是只读的，不能更新。\n例：使用OLD保存将要被删除的行到一个存档表中：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE TRIGGER deleteorder BEFORE DELETE ON orders\nFOR EACH ROW\nBEGIN\n\tINSERT INTO archive_orders(order_num, order_date, cust_id)\n    VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);\nEND;\n")])])]),a("p",[t._v("在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）。")]),t._v(" "),a("h4",{attrs:{id:"update触发器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update触发器"}},[t._v("#")]),t._v(" UPDATE触发器")]),t._v(" "),a("p",[t._v("UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：")]),t._v(" "),a("ul",[a("li",[t._v("在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新 更新的值；")]),t._v(" "),a("li",[t._v("在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；")]),t._v(" "),a("li",[t._v("OLD中的值全都是只读的，不能更新。\n下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大写还是小写）：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors\nFOR EACH ROW SET NEW.vend_state = Upper(New.vend_state);\n")])])]),a("p",[t._v("每次更新一个行时，NEW.vend_state中的值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。")]),t._v(" "),a("h4",{attrs:{id:"关于触发器的进一步介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于触发器的进一步介绍"}},[t._v("#")]),t._v(" 关于触发器的进一步介绍")]),t._v(" "),a("ul",[a("li",[t._v("与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的MySQL版本中有一些改进和增强触发器支持的计划。")]),t._v(" "),a("li",[t._v("创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行。")]),t._v(" "),a("li",[t._v("应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。")]),t._v(" "),a("li",[t._v("触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。")]),t._v(" "),a("li",[t._v("遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);